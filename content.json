{"pages":[],"posts":[{"title":"Swift编译过程","text":"不积跬步无以至千里 LLVMLLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)。 LLVMIRLLVM中间层表示 ClangClang是一个由Apple主导编写，基于LLVM的C/C++/Objective-C轻量编译器 swiftc的命令行 swiftc -o main.out main.swift 编译成可执行文件 Swift Abstract Syntax Tree(AST) swiftc main.swift -dump-ast 生成抽象语法树 Swift Intermediate Language(SIL) swiftc main.swift -emit-sil 生成swift中间语言 LLVM Intermediate Representation(LLVM IR) swiftc main.swift -emit-ir 生成LLVM中间表示层数据 Assembly Language swiftc main.swift -emit-assembly 生成汇编语言","link":"/2019/12/12/Swift%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"title":"工作流程引擎","text":"0、为什么要使用工作流引擎假定我们有一个支付订单状态需要维护，它的状态图如下： 它的状态跃迁自左向右，清晰名了，而且没有处理角色的概念，此时我们使用代码控制好状态流转即可，无需使用框架。 再来看另外一个场景，假定我们有一个企业内部采购订单，它的状态图如下： 这个采购订单的状态复杂多变，状态的转换不稳定性很强，随时有可能增加新的状态；而且不同状态的处理人也是不同的，存在权限管理功能，若此时我们仍然使用一个状态字段来维持状态变更，无疑会困难重重。 工作流引擎就是为了解决这类问题而生的，我们可以观察当前实体(如支付订单、采购订单)是否具有如下特性，由此来确定是否需要引入工作流引擎。 状态的个数及其稳定性，个数多且不稳定，适合使用工作流引擎。 每个状态的处理人，处理人角色多且不稳定，适合使用工作流引擎。 工作流引擎实际上是放大了状态管理的功能，它根据既有流程图（基于 BPMN2.0 规范）的指示，指定每一次状态跃迁的处理角色，在状态变更时持久化评论、表单、附件等数据，保存了完整处理轨迹。 工作流引擎最常见用于审批流程中，现在一线互联网公司也开始使用，并有快速推广的趋势，复杂繁多的业务流程如果采用 if else 实现那将是崩溃的，代码不可维护，业务流程在代码中可读性很差，所以高人设计了业务流程模型图示 BPMN2.0 规范，我们要做到就是把业务场景抽象为标准流程图，把流程图丢到流程引擎中按流程定义约定逐步流转，很显然扩展性和业务可描述性会好很多，所以工作流引擎主要用于解决复杂的业务，目前经常被提起的中台系统抽象业务为服务，也涉及大量智能的业务流程引擎做支撑。 1、工作流概念1.1 流程的定义从最朴素和最直接的角度看，我们按照条理和顺序做事情的过程，就是流程。 流程之父迈克尔.哈默是这样定义的： 流程是把一个或多个输入转化对顾客有价值的输出的活动。 李.克拉耶夫斯基和拉里.里茨曼在其《运营管理–流程与价值链》第 7 版中是这样定义的： 流程是一种或一组活动，这些活动利用一个或多个输入要素，对起进行转换并 3 使其增值，向顾客提供一种或多种产出。 我们的理解是： 流程就是一组活动按照一定的顺序组成的序列流，其顺序可能是串行的、并行的，或者两者的组合模式，例如面包制作流程中的“混合原料”，“揉面醒发”，“整形”，“烘烤”等活动。 综上所述，流程一般具备六个要素：输入、活动、活动间的相互作用、输出、流程的服务对象和价值。 如下图所示： 1.2 工作流参考模型1993 年，工作流管理联盟（WfMC）成立，接着发布了著名的工作流参考模型（如下图所示）及接口规范。2002 年 10 月 25 日，WFMC 发布了 XPDL 1.0 规范(WFMC-TC-1025)、规范流程定义的 XML 描述形式。 WFMC 定义的 5 类接口的功能： 接口 1：过程定义输入输出接口，工作流服务和工作流建模工具间接口，包括工作流模型的解释和读写操作； 接口 2：客户端函数接口，工作流服务和客户应用之间的接口，这是最主要的接口规范，它约定所有客户方应用与工作流服务之间的功能操作方式； 接口 3：激活应用程序接口，工作流机和直接调用的应用程序之间的直接接口； 接口 4：工作流执行服务之间的互操作接口，工作流系统之间的互操作接口； 接口 5：系统管理与监控接口，工作流服务于工作流管理工具之间的接口； 1.3 主要应用场景 一般 OA 都内置有一个轻量级的审批流引擎，适用于办公协同领域。BPM 呢，在中国主要适用于流程化信息化程度较高的制造业、零售业、房地产、金融业和政府事业单位，可以应用在企业战略、运营、管理等从上到下的各个场景。BPM 主要为这些行业中体量较大的公司客户服务。 2、 工作流规范简介20 世纪 70 年代中期，工作流出现并运用于办公自动化领域，使流程管理技术第一次有了系统的技术规范。20 世纪 80 年代 初期，工作流伴随着 OA 系统走向商用，但是应用范围有限。至 80 年代后期，OA 系统的研究被群件和工作流管理系统所代替。20 世纪 90 年代以后，相关技术逐渐成熟，工作流管理联盟(WfMC)成立并发布了工作流参考模型。进入 21 世纪， BPM 更进一步发展。SOA 的出现使得流程管理技术从工作流转向业务流，基于此的一系列规范也相应被推出。 发展到目前，BPMN 规范最完善，现在主流工作流引擎产品，大多基于 BPMN2.0 规范实现的，这里只介绍 BPMN2.0 规范。 2.1 BPMN2.0 规范业务流程模型和标记法（BPMN, Business Process Model and Notation）是一套图形化表示法，用于以图形的方式详细说明各种业务流程。 它最初由业务流程管理倡议组织（BPMI, Business Process Management Initiative）开发，名称为”Business Process Modeling Notation”，即“业务流程建模标记法”。BPMI 于 2005 年与对象管理组织（OMG, Object Management Group）合并。2011 年 1 月 OMG 发布 2.0 版本（时至今日，没人会用 1.0 版本了），同时改为现在的名称。 BPMN2.0 规范的实现，实质上是一个按照特定规范编写的 XML 文件，使用特定的 BPMN 设计器，即可以图形化的形式查看和编辑该文件。Camunda，Activiti，Flowable 等主流的 java 开源流程引擎，以代码的形式实现了这套图形化表示法，使任务的流转依赖图形，而非具体的实现代码。 UML vs BPMN UML 和 BPMN 之间唯一的正式关系是 OMG 维护两个开放标准。 UML(统一建模语言)作为一种可视化的建模语言，其中的活动图也适用于流程建模，但其支持深度不够。 BPMN 诞生时间晚于 UML，据称从某种意义上讲，UML Activity Diagrams 是 BPMN 的一个子集，也是 BPMN 的历史前身。 BPMN2.0，流程主要涉及的对象： 如上图所示，BPMN2.0 规范主要包含了三个部分 Activities(活动)、Gateway(网关)、Event(事件)。 下图在线流程设计器，设计的流程图效果如下： 2.2 流程技术发展历史流程管理思想及方法论的发展，深刻影响着流程技术的发展，而流程技术的发展也反过来促进了流程管理思想的发展，二者相辅相成，互相促进。流程技术的发展大概经理了三个发展阶段： 工作流技术阶段 工作流技术在以“信息技术驱动的技术流程自动化”管理思想为主导的时代进入了新的热潮。此阶段的主要技术是 OO 技术、Web 1.0 及 ERP、OA 等，而 ERP 及 OA 都是基于工作流技术的应用。 BPM 技术阶段 在“业务流程为主导的管理思想”时期，业务流程管理系统/套件（BPMS）出现了，BPMS 所要解决的问题是怎么以业务流程为中心全面串联企业的经营活动。要达到这个目标，首先要全面梳理和设计企业的所有业务流程，最终通过 BPMS 进行落地实现。在这个时期，出现了 Web 服务，SOA 和 ESB（企业服务总线）等技术。 BPM 治理阶段 为了提高 BPM 实施的成功率及投资回报率而引入了一些新的管理思想和技术，这些管理思想及技术终极目标还是围绕 BPM 的。 流程规范、技术进展技术路线图 3、工作流和 BPM 的区别啥叫 BPM，来点小科普。讲 BPM，我们首先就要清楚什么叫业务流程，或者说什么是业务，然后才能明白什么叫业务流程管理。 业务流程简单来说就是业务处理流，或者说业务的流转过程。这里重要的不是“流程”二字，而是“业务”二字。注意，类似于请假不能算是企业的“业务”。例如，你去见一个新客户，客户问你，你的公司主要做什么业务？你总不能说我们公司是做“请假”业务的吧？那么到底业务流程关注的是什么样的业务呢？一句话，对顾客产生价值的流程就是我们这里所关注的“业务流程”。 产品和服务的设计与开发 产品和服务的市场营销与销售 产品和服务的交付 客户服务管理 业务流程管理是一种以规范化地构造端到端的卓越业务流程为中心，以持续地提高组织业务绩效为目的的系统化管理方法。 3.1 定义不同工作流系统是指通过电子版代替纸质版帮助企业处理所有内部事务，实现各种审批工作，支持协同工作中的一部分。 BPM 系统即业务流程是指企业、政府以及其它各种组织,为了达到其业务目标,利用技术实现业务自动化，协助企业业务发展。 3.2 流程架构不同工作流系统是从企业内部出发，单一只对企业本部门或者本业务的业务需求，部门与部门之间流程无法衔接，信息的共享和传递困难，存在大量流程断点。 而 BPM 系统可以实现各流程之间可以衔接、协调，避免了流程孤岛的产生。同时，在激烈的市场竞争环境下，对提高整个业务流程运行的效率、成本、等满足客户的需求。 3.3 应用不同工作流系统是为帮助企业解决“办公自动化”、“流程自动化”而诞生的应用技术，却不对业务流程进行优化的，功能较单一。 而 BPM 系统可以对业务全过程进行管理，如分析，整合、协助等，确保工作流能够按计划实施。 3.4 集成功能不同工作流系统只能对单一业务进行处理。 BPM 可以帮助软件开发人员来集成第三方的应用软件。例如 ERP、PLM、财务软件等可以通过 BPM 平台进行集成。 3.5 流程的持续改进不同工作流系统由于业务人员对其缺少认识和关注，及工作流系统本身缺少对内部业务的连接，因此很难对流程进行持续改进。 而 BPM 系统由于可以帮助业务人员密切关注信息系统内嵌流程与其它业务流程衔接关系，可以及时进行流程的调整、改进等，最终是为了优化、提升和自动化处理业务流程。 总之，随着信息技术的高速发展，业务不断扩大，工作流技术一直是企业信息化建设不可或缺的一部分。不管是办公自动化 OA 系统，还是企业 ERP 系统的部署，利用工作流系统和 BPM 系统都是可以提高企业运行效率的。 4、市场上工作流厂商分类只提供工作流产品。这类厂商产品单一，尽管产品质量能够得到保证，但是发展最为困难。技术在这里不是第一竞争力。 提供工作流产品和快速开发平台。这类厂商在工作流的基础上提供开发框架进一步简化编程，相比第一类厂商会更有竞争力，但是其发展受到系统集成商的限制。 提供工作流产品和业务套件/平台，同时自己接项目。与单纯的快速开发平台相比，业务平台显然站在了一个更高的层次上。在软件开发中，最大的浪费往往并不在于技术本身，而是在于对业务的不熟悉，在于核心领域模型的频繁变动。对用户而言，根据需要选择合适业务平台和相关服务无疑能够产生最大的价值。这是目前生存状态比较好的厂商，多是老牌厂商或是有充足的资金。业务套件/平台能够给用户提供最大的价值。在任何时候，直接面对最终用户就是王道。 工作流厂商的机会在哪里？ 最重要的就是，将产品面向最终用户。 提供行业应用业务套件。能够做到对某类应用的快速实施，很多功能能够做到开箱即用。 转向 BPMS。这个需要两方面的努力：一是业务方面需要与业务流程咨询公司进行合作；二是产品需要增加 BPMS 特性。 自己做项目。大公司靠财务，小公司靠销售。 5、流程引擎发展趋势5.1 趋势一：中台化对于信息化软件的演进，从流程线和开发部署方式两条线来看，分别从轻到重和从重到轻发展，交汇于数字中台。从部署 开发一线来看，传统的开发部署模式时间长、成本高、系统割裂，不能满足企业实现“成本效益”的需求，因而数字中台 转型成为必然的选择。 5.2 趋势二：低代码需求端的 复杂多变对软件开发提出了新的要求，市场要求软件的开发的速度越快越好、交付时间越来越短，“低代码”应运而生。 BPM 在未来也将充分与低代码相结合，BPM 的低代码化主要包含设计端的应用。开发人员寻找通用的开发活动，然后为 所有环节构建一个基本代码并将它们封装在某个可视化的模块里。基于这些模块，业务人员就可以通过拖拉拽的方式，在 可视化的设计器上像“搭积木”一样，对表单、流程和应用进行搭建。这种方式极大地提高了软件开发的敏捷性，同时实 现了“以客户为中心”，使公司更好的响应市场。 5.3 趋势三：智能化业务流程管理（BPM）已成为企业内部优化的选择。流程的优化通过节省时间并降低成本为公司带来竞争优势，使员工更 有效地工作。随着市场的成熟度日益提高，各种新兴技术不断发展，BPM 自身也需要与时代结合，不断发展。未来 BPM 将进一步与 RPA（机器人流程自动化）、AI（人工智能）等智能化技术相结合，为企业提供更敏捷、优质的服务。 6、开源流程引擎目前 java 主流的开源流程引擎，有 jBPM，Activiti，Camunda，Flowable 等。","link":"/2021/09/16/%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E/"},{"title":"iOS性能优化整理","text":"iOS性能优化整理一、性能优化–卡顿卡顿的原因主要是CPU、GPU引起的 CPU(中央处理器): 对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制(Core Graphics)GPU(图形处理器)：纹理的渲染 卡顿优化–CPU1尽量试用轻量级对象，比如用不到事件处理的地方可以考虑试用CALayer取代UIView23不要频繁的调用UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改45尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性67Autolayout会比直接设置frame消耗更多的CPU资源89图片的size最好刚好跟UIImageView的size保持一致1011控制一下线程的最大并发数量1213尽量把耗时的操作放在子线程，比如文本处理（尺寸计算、绘制），图片处理（解码、绘制） 卡顿优化–GPU1尽量避免短时间内大量图片的显示，尽可能多张突变合成一张显示。23GPU能处理的最大纹理尺寸是 4096 x 4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尺寸尽量不要超过这个尺寸45尽量减少试图数量和层次67减少透明的视图(alpha &lt; 1)，不透明的就设置opaque为YES89尽量避免出现离屏渲染(设置view的圆角、遮罩、阴影) 离屏渲染在OpenGL中，GPU有两种渲染方式 on-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作 off-Screen Rendering：离屏渲染，在当前屏幕缓冲区以外开辟一个新的缓冲区进行渲染操作。 离屏渲染消耗性能的原因： 11、需要创建新的缓冲区232、离屏渲染的整个过程，需要多次切换上下文环境，显示从当前屏幕切换到离屏，等到离屏渲染结束后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕。 哪些操作会触发离屏渲染 11. 光栅化，layer.shouldRasterize = YES;232. 遮罩，layer.mask453. 圆角，同时设置layer.masksToBounds = YES，layer.cornerRadius 大于 06 可以考虑通过CoreGraphice绘制裁剪圆角，或者叫美工提供圆角图片。784. 阴影，layer.shadowXXX，如果设置了layer.shadowPath 就不会产生离屏渲染 二、性能优化–耗电优化app中主要的耗电来源于： CPU处理、网络、定位、图像处理 优化方案： 尽可能降低CPU、GPU功耗 减少使用定时器 优化I/O操作，例如： 11. 尽量不要频繁的写入小数据，最好批量一次写入22. 读写大量重要数据时，考虑用dispatch_io，其提供了基于GCD的异步操作文件I/O的的API。用dispatch_io系统会优化磁盘访问33. 数据量比较大时，建议使用数据库(比如SQLite、CoreData) 网络优化 11. 减少、压缩网络数据22. 如果多次请求的结果是相同的，尽量使用缓存33. 使用断点续传，否则网络不稳定时可能多次传输相同的内容44. 网络不可用时，不要尝试执行网路请求55. 让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间66. 批量传输，比如：下载视频时，不要传输很小的数据包，直接下载整个文件或者一大块一大块的下载。如果下载广告，一次性多下载一些，然后在慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封的下载 定位优化11、如果只是需要快速确认用户位置，最好用CLLocationManager的requestLocation，定位完后，会自动让定位硬件断电。22、如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务33、尽量降低定位精度，比如尽量不要使用最高的kCLLocationAccuracyBest44、需要后台定位时，尽量设置pausesLocationUpdatesAutomaticall为YES，如果用户不太可能移动的时候系统会自动暂停位置更新 三、 性能优化 – APP启动优化 APP冷启动可以概括为三个阶段 dyld runtime main dyld runtime APP启动优化方案： 四、 安装包瘦身","link":"/2021/09/08/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%86/"},{"title":"mysql性能优化（内部培训笔记）","text":"mysql性能优化方案存储引擎InnoDB：事务安全、行级锁定、主键索引、支持外键（5.7版本的默认存储引擎，推荐） CSV：表格 Archive：日志系统、历史数据、大量的设备数据采集 Memory：redis，查找热度比较高的数据 MyISAM:5.5以前的默认版本 Federated:分布式、远程获取数据（远程表） 索引排序，随机io变有序io 适合大中型表 MySQL中使用的是B+Tree：所有数据存在叶子节点，左闭合 优化建议：索引列的数据长度能少则少；不一定越多越好；覆盖索引，少用select *；列的离散性要好 explain 执行计划 锁","link":"/2019/12/11/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%86%85%E9%83%A8%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0%EF%BC%89/"},{"title":"开篇","text":"长风破浪会有时，只怪云帆济沧海 自己本人卢希强，别名小希，28岁，居住在武汉，一个2015年毕业的软件开发工程师，四年多时间沉心工作，职业搬砖，知识零碎，回头皆空。兴趣爱好广泛，一切运动、唱歌、游戏……无奈时间不允许。回归近三十年人生路，波澜不惊，平平淡淡，车房都有，即将结婚。特开博客记录生活工作点滴。 生活 不求大富大贵，但求平安风顺 结婚在即，奔三冲刺，平平安安才是真。 工作 Stay hungry, stay foolish 专职于iOS开发，四年半开发经验，工作之余接触关于web端的相关知识。感觉技术日新月异，不往前便落后，所以坚持学习、坚持笔记、坚持coding吧。 目标 先定个小目标，赚他个一个亿？ 1、学习flutter,copy一个完整的公司项目； 2、减肥30斤； 3、学习SwiftUI、vue等； 4、每月一本书； 5、赚钱赚钱。 最后 会当凌绝顶，一览众山喜爱 祝自己工作顺利，升职加薪，生活幸福，股市长虹！ 2020为了生活，冲鸭！","link":"/2019/12/02/%E5%BC%80%E7%AF%87/"},{"title":"正则表达式全集","text":"字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo能匹配“z”以及“zoo”。等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（,+,?，{*n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“`(. (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\\(”或“\\)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`( (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows`”。 x|y 匹配x或y。例如，“`z [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \\d 匹配一个数字字符。等价于[0-9]。 \\D 匹配一个非数字字符。等价于[^0-9]。 \\f 匹配一个换页符。等价于\\x0c和\\cL。 \\n 匹配一个换行符。等价于\\x0a和\\cJ。 \\r 匹配一个回车符。等价于\\x0d和\\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于\\x09和\\cI。 \\v 匹配一个垂直制表符。等价于\\x0b和\\cK。 \\w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04&amp;1”。正则表达式中可以使用ASCII编码。. *num* 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。 *n* 标识一个八进制转义值或一个向后引用。如果*n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n*为一个八进制转义值。 *nm* 标识一个八进制转义值或一个向后引用。如果*nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm*。 *nml* 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 常用正则表达式 用户名 /^[a-z0-9_-]{3,16}$/ 密码 /^[a-z0-9_-]{6,18}$/ 十六进制值 /^#?([a-f0-9]{6}|[a-f0-9]{3})$/ 电子邮箱 /^([a-z0-9_.-]+)@([\\da-z.-]+).([a-z.]{2,6})$/ /^[a-z\\d]+(.[a-z\\d]+)*@(\\da-z?)+(.{1,2}[a-z]+)+$/ URL /^(https?://)?([\\da-z.-]+).([a-z.]{2,6})([/\\w .-])/?$/ IP 地址 /((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)/ /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/ HTML 标签 /^&lt;([a-z]+)([^&lt;]+)(?:&gt;(.)&lt;/\\1&gt;|\\s+/&gt;)$/ 删除代码\\注释 (?&lt;!http:|\\S)//.*$ Unicode编码中的汉字范围 /^[\\u2E80-\\u9FFF]+$/","link":"/2020/04/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A8%E9%9B%86/"},{"title":"面向对象的一些事","text":"由来 很久以前，软件开发的世界还是一片浑浑噩噩，不管开发什么软件都面临着复杂性这个问题，代码里面到处是goto语句，程序的流程随意跳转。众生写代码时，越写到后面越不知道自己写的是什么。这时候出现一位巨人，他就是结构化编程。 结构化编程的基本思想是：有序地控制流程，即把程序的执行顺序限制为顺序、分支和循环这三种；把共通的处理归结为例程（函数）。 虽然结构化解决了程序控制流的复杂问题，但程序里面不仅包括控制结构，还包括要处理的数据。随着处理数据的增加，程序的复杂性也会上升。这时候，面向对象编程来了！ Simula 面向对象技术最早是在编程语言Simula中提出的。1967年5月20日，在挪威奥斯陆郊外的小镇莉沙布举行的IFIP TC-2 工作会议上，挪威科学家Ole-Johan Dahl和Kristen Nygaard正式发布了Simula 67语言。Simula 67被认为是最早的面向对象程序设计语言，是面向对象的开山祖师，它引入了所有后来面向对象程序设计语言所遵循的基础概念：对象、类、继承，但它的实现并不是很完整。 Simula虽然最早提出面向对象的概念，但因为其本身复杂，比较难学，而并没有大规模流行。但Simula提出的面向对象的概念对程序语言后继的发展产生了巨大和深远的影响。 Smalltalk Smalltalk是公认为历史上第二个面向对象的程序语言，而且是第一个完整实现了面向对象技术的语言。 最早的Smalltalk原型由艾伦·凯于70年代初提出。类（来自Simula-67）、海龟绘图（来自MIT的LOGO）以及图形界面等概念的有机组合，构成了Smalltalk的最初的蓝图。在1971年到1975年之间，艾伦·凯在Xerox PARC的小组设计并实现了第一个真正的Smalltalk语言系统。 Smalltalk引领了面向对象的设计思想的思潮，对其它众多的程序设计语言的产生起到了极大的推动作用。C++，C#，Objective-C，Actor，Java和Ruby等，无一不受到Smalltalk的影响，这些程序语言中也随处可见Smalltalk的影子。 除了编程语言受到Smalltalk的影响外，90年代的许多软件开发思想得利于Smalltalk，例如设计模式、敏捷编程和代码重构等。 面向对象与基于对象的区别 “面向对象”和“基于对象”两个不同的概念。面向对象的三大特点（封装，继承，多态）缺一不可，通常“基于对象”使用对象，但是无法利用现有的对象模板产生新的对象类型，继而产生新的对象，也就是说“基于对象”没有继承的特点，而“多态”是表示为父类类型的子类对象实例，没有了继承的概念也就无从谈论“多态”。现在的很多流行技术都是基于对象的，它们使用一些封装好的对象，调用对象的方法，设置对象的属性。但是它们无法让程序员派生新对象类型。他们只能使用现有对象的方法和属性。所以当你判断一个新的技术是否是面向对象的时候，通常可以使用后两个特性来加以判断。 面向对象的三个基本特征继承 继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。 实现继承是指直接使用基类的属性和方法而无需额外编码的能力； 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。 多态 多态即一个名字有多种语义，一个词法元素可以作多种解释。面向对象系统，对象封装了操作，利用重名的操作，让各对象自己去释意执行，这种多义性不会带来混淆，方便与高层设计。虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。 封装 面向对象的诸多优点是靠封装手段得到“对象”而获得的。封装的目的在于将对象用户和对象的实现者分开，用户不必知道对象行为实现的细节，只要以实现者提供的消息来访问该对象。封装是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。 最后1、抽象会使复杂的问题更加简单化。2、从以前面向过程的执行者，变成了张张嘴的指挥者。3、面向对象更符合人类的思维，面向过程则是机器的思想","link":"/2020/04/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"},{"title":"舒适终端","text":"iTerm2 + Oh My Zsh自定义终端（Mac） homebrew、Xcode、git、iterm2、zsh Step1 下载iTerm2下载地址：https://www.iterm2.com/ 老版本MacOS需手动切换zsh，执行以下命令 1chsh -s /bin/zsh 如果想切回bash，执行以下命令 1chsh -s /bin/bash Step2 安装Oh My Zshcurl安装 1# curl 安装方式2sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" wget安装 1# wget 安装方式2sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 地址：https://github.com/robbyrussell/oh-my-zsh Step3 安装PowerLine首先安装pip，已经安装的跳过 1sudo easy_install pip 安装powerline 1pip install powerline-status --user Step3 选择字体和配色iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text自行选择 Step4 选择主题下载agnoster主题 1cd ~/Desktop/OpenSource2git clone https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor.git3cd oh-my-zsh-agnoster-fcamblor/4./install 打开zshrc配置文件，将ZSH_THEME后面的字段改为”agnoster” 1oepn ~/.zshrc 修改完成后，执行配置 1source ~/.zshrc Step5 安装高亮插件1cd ~/.oh-my-zsh/custom/plugins/2git clone https://github.com/zsh-users/zsh-syntax-highlighting.git3open ~/.zshrc 这时我们再次打开zshrc文件进行编辑。找到plugins，此时plugins中应该已经有了git，我们需要把高亮插件也加上： 请务必保证插件顺序，zsh-syntax-highlighting必须在最后一个。 然后在文件的最后一行添加：source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 执行命令使刚才的修改生效： 1source ~/.zshrc 最后愉快的去使用吧！","link":"/2019/12/24/%E8%88%92%E9%80%82%E7%BB%88%E7%AB%AF/"}],"tags":[],"categories":[]}