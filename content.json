{"pages":[],"posts":[{"title":"Swift编译过程","text":"不积跬步无以至千里 LLVMLLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)。 LLVMIRLLVM中间层表示 ClangClang是一个由Apple主导编写，基于LLVM的C/C++/Objective-C轻量编译器 swiftc的命令行 swiftc -o main.out main.swift 编译成可执行文件 Swift Abstract Syntax Tree(AST) swiftc main.swift -dump-ast 生成抽象语法树 Swift Intermediate Language(SIL) swiftc main.swift -emit-sil 生成swift中间语言 LLVM Intermediate Representation(LLVM IR) swiftc main.swift -emit-ir 生成LLVM中间表示层数据 Assembly Language swiftc main.swift -emit-assembly 生成汇编语言","link":"/2019/12/12/Swift%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"title":"iOS性能优化整理","text":"iOS性能优化整理一、性能优化–卡顿卡顿的原因主要是CPU、GPU引起的 CPU(中央处理器): 对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制(Core Graphics)GPU(图形处理器)：纹理的渲染 卡顿优化–CPU1尽量试用轻量级对象，比如用不到事件处理的地方可以考虑试用CALayer取代UIView23不要频繁的调用UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改45尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性67Autolayout会比直接设置frame消耗更多的CPU资源89图片的size最好刚好跟UIImageView的size保持一致1011控制一下线程的最大并发数量1213尽量把耗时的操作放在子线程，比如文本处理（尺寸计算、绘制），图片处理（解码、绘制） 卡顿优化–GPU1尽量避免短时间内大量图片的显示，尽可能多张突变合成一张显示。23GPU能处理的最大纹理尺寸是 4096 x 4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尺寸尽量不要超过这个尺寸45尽量减少试图数量和层次67减少透明的视图(alpha &lt; 1)，不透明的就设置opaque为YES89尽量避免出现离屏渲染(设置view的圆角、遮罩、阴影) 离屏渲染在OpenGL中，GPU有两种渲染方式 on-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作 off-Screen Rendering：离屏渲染，在当前屏幕缓冲区以外开辟一个新的缓冲区进行渲染操作。 离屏渲染消耗性能的原因： 11、需要创建新的缓冲区232、离屏渲染的整个过程，需要多次切换上下文环境，显示从当前屏幕切换到离屏，等到离屏渲染结束后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕。 哪些操作会触发离屏渲染 11. 光栅化，layer.shouldRasterize = YES;232. 遮罩，layer.mask453. 圆角，同时设置layer.masksToBounds = YES，layer.cornerRadius 大于 06 可以考虑通过CoreGraphice绘制裁剪圆角，或者叫美工提供圆角图片。784. 阴影，layer.shadowXXX，如果设置了layer.shadowPath 就不会产生离屏渲染 二、性能优化–耗电优化app中主要的耗电来源于： CPU处理、网络、定位、图像处理 优化方案： 尽可能降低CPU、GPU功耗 减少使用定时器 优化I/O操作，例如： 11. 尽量不要频繁的写入小数据，最好批量一次写入22. 读写大量重要数据时，考虑用dispatch_io，其提供了基于GCD的异步操作文件I/O的的API。用dispatch_io系统会优化磁盘访问33. 数据量比较大时，建议使用数据库(比如SQLite、CoreData) 网络优化 11. 减少、压缩网络数据22. 如果多次请求的结果是相同的，尽量使用缓存33. 使用断点续传，否则网络不稳定时可能多次传输相同的内容44. 网络不可用时，不要尝试执行网路请求55. 让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间66. 批量传输，比如：下载视频时，不要传输很小的数据包，直接下载整个文件或者一大块一大块的下载。如果下载广告，一次性多下载一些，然后在慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封的下载 定位优化11、如果只是需要快速确认用户位置，最好用CLLocationManager的requestLocation，定位完后，会自动让定位硬件断电。22、如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务33、尽量降低定位精度，比如尽量不要使用最高的kCLLocationAccuracyBest44、需要后台定位时，尽量设置pausesLocationUpdatesAutomaticall为YES，如果用户不太可能移动的时候系统会自动暂停位置更新 三、 性能优化 – APP启动优化 APP冷启动可以概括为三个阶段 dyld runtime main dyld runtime APP启动优化方案： 四、 安装包瘦身","link":"/2021/09/08/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%86/"},{"title":"bpmn流程模式","text":"BPM常见的流程模式有：顺序流程、会签流程、或签流程、分支流程、并行流程、子流程、任意流程等，这些流程模式均在BPMN2.0规范中有明确的定义，activiti、flowable、camunda等开源工作流引擎也都支持这些模式，以下重点介绍会签流程、或签流程、分支流程、并行流程这四种流程模式。 一、会签流程1、适用场景会签是一种联合审批的特殊审批节点，可理解为一种多人投票机制，一个任务需要多个人同时处理，然后汇总多个人的意见，决定流程下一步该如何执行。流程设计时，若会签审批节点中设置多个参与人，流程运行时，会签节点任务需要多人共同处理，然后汇总多人的处理意见，决定会签节点的处理结果。例如：员工发起采购申请，需经过多名领导共同审批后，才决定是否可以采购，只要其中1名领导不同意，便退回申请人。 2、具体规则会签分并行会签和顺序会签两种：并行会签：指同一个审批节点设置多个人，如ABC三人，三人会同时收到待办，需全部同意之后，审批才可到下一审批节点。顺序会签：指同一个审批节点设置多个人，如ABC三人，三人按顺序依次收到待办，即A先审批，A提交后B才能审批，需全部同意之后，审批才可到下一审批节点。 3、设置方法BPMN2.0规范中提供了bpmn:multiInstanceLoopCharacteristics多实例循环的模型定义，activiti、flowable、camunda等开源工作流引擎均支持该属性，云程BPM基于camunda实现，对bpmn:multiInstanceLoopCharacteristics进行了封装，提供了界面可视化配置功能，并支持多人并行会签和多人顺序会签的功能，顺序会签在一些特定的业务场景下是有用的，个别中国特色流程需求有审批顺序的要求。 二、或签流程1、适用场景一个流程审批节点里有多个处理人，任意一个人处理后就能进入下一个节点。例如：员工发起采购申请，提交给多名领导审批，只要有一名领导同意即可提交到下一节点。 2、具体规则指同一个审批节点设置多个人，如ABC三人，三人会同时收到审批待办，只要其中任意一人审批即可到下一审批节点。 3、设置方法BPMN2.0规范中提供了bpmn:multiInstanceLoopCharacteristics多实例循环的模型定义，并通过bpmn:completionCondition标签定义多实例完成条件，activiti、flowable、camunda等开源工作流引擎均支持该属性，云程BPM基于camunda实现，对bpmn:multiInstanceLoopCharacteristics和bpmn:completionCondition进行了封装，提供了界面可视化配置功能，配置多人办理规则为“多人任意”即可实现该功能。 三、分支流程1、适用场景分支流程的适用场景：流程中某个节点后有多个分支节点，根据不同条件执行不同的分支，即不同的数据会走不同的流程路径。例如：请假申请，可根据请假天数走不同的审批路径，3天以内请假由人力资源审批，超过3天的请假由公司领导审批。 2、具体规则1、分支流程使用【排他网关】，连接在【排他网关】后面的线条，有分流作用，点击线条可设置流转条件；2、上一节点点击【提交】后，根据【排他网关】设置按顺序判断所有分支流转条件，出现满足流转条件时，就进入相应的分支节点。3、如果不设置，表示无条件限制，会直接进入该节点；如果设置了流转条件，则只有满足条件才会进入该节点；如果所有的条件都不满足，则会流转到设置的默认方向；如果有多个条件满足，则会按设置的条件顺序判断，直到出现第一个满足的条件，就进入该节点。 3、设置方法BPMN2.0规范中提供了bpmn:exclusiveGateway排他网关标签，activiti、flowable、camunda等开源工作流引擎均支持该标签，云程BPM基于camunda实现，严格遵照标准的BPMN2.0网关模型，并提供了界面可视化配置功能。 四、并行流程1、适用场景并行流程适用场景：流程中某个节点后有多个节点需要并行执行，节点的处理人需同时收到流程待办，各自处理待办，当所有分支线上的节点都执行后，流程才进入到下一个节点。例如：员工提交请假申请，同时送部门经理和人力资源部审批，需要部门经理和人力资源全部审批通过后，才算流程审批通过。 2、具体规则1、【并行网关】必须成双使用，连接在【并行网关】后面的线条，才有并流作用；2、上一节点点击【提交】后，无论线条是否设置条件，都自动进入所有的分支节点。当所有分支都执行后，才进入这些分支同时连接的下一个节点； 3、设置方法BPMN2.0规范中提供了bpmn:parallelGateway并行网关标签，activiti、flowable、camunda等开源工作流引擎均支持该标签，云程BPM基于camunda实现，严格遵照标准的BPMN2.0网关模型，并提供了界面可视化配置功能。","link":"/2021/09/18/bpmn%E6%B5%81%E7%A8%8B%E6%A8%A1%E5%BC%8F/"},{"title":"hexo搭建流程","text":"使用hexo+github搭建免费个人博客详细教程目录 前言 准备工作 搭建github博客 创建仓库 绑定域名 配置SSH key 测试是否成功 使用hexo写博客 hexo简介 原理 注意事项 安装 初始化 修改主题 上传之前 上传到github 保留CNAME、README.md等文件 常用hexo命令 _config.yml 写博客 写博客工具 如何让博文列表不显示全部内容 最终效果 参考 本文目录（注意无法点击）： 前言体验更加排版请访问原文链接：http://blog.liuxianan.com/build-blog-website-by-hexo-github.html 使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 等等； 1.1. 准备工作在开始一切之前，你必须已经： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git for windows（或者其它git客户端） 本文所使用的环境： Windows8.1 node.js@5.5.0 git@1.9.2 hexo@3.2.2 搭建github博客2.1. 创建仓库新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 2.2. 绑定域名当然，你不绑定域名肯定也是可以的，就用默认的 xxx.github.io 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。 首先你要注册一个域名，域名注册以前总是推荐去godaddy，现在觉得其实国内的阿里云也挺不错的，价格也不贵，毕竟是大公司，放心！ 绑定域名分2种情况：带www和不带www的。 域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问，如下： 然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试： 如果你填写的是没有www的，比如 mygit.me，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://mygit.me 如果你填写的是带www的，比如 www.mygit.me ，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://www.mygit.me 如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 http://abc.mygit.me 没问题，但是访问 http://mygit.me ，不会自动跳转到 http://abc.mygit.me 另外说一句，在你绑定了新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。 配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 1ssh-keygen -t rsa -C \"邮件地址\" 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 将刚复制的内容粘贴到key那里，title随便填，保存。 3.1. 测试是否成功1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 此时你还需要配置： 1$ git config --global user.name \"liuxianan\"// 你的github用户名，非昵称2$ git config --global user.email \"xxx@qq.com\"// 填写你的github注册邮箱 具体这个配置是干嘛的我没仔细深究。 使用hexo写博客4.1. hexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网： http://hexo.iogithub: https://github.com/hexojs/hexo 4.2. 原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 4.3. 注意事项安装之前先来说几个注意事项： 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 4.4. 安装1$ npm install -g hexo 4.5. 初始化在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是F:\\Workspaces\\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 1$ cd /f/Workspaces/hexo/2$ hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： 1$ hexo g # 生成2$ hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的： hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章： http://blog.liuxianan.com/windows-port-bind.html 第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑，打开时就是这个样子： 4.6. 修改主题既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。 个人比较喜欢的2个主题：hexo-theme-jekyll 和 hexo-theme-yilia。 首先下载这个主题： 1$ cd /f/Workspaces/hexo/2$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载后的主题都在这里： 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 4.7. 上传之前在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 4.8. 上传到github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。 首先，ssh key肯定要配置好。 其次，配置_config.yml中有关deploy的部分： 正确写法： 1deploy:2 type: git3 repository: git@github.com:liuxianan/liuxianan.github.io.git4 branch: master 错误写法： 1deploy:2 type: github3 repository: https://github.com/liuxianan/liuxianan.github.io.git4 branch: master 后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误： 1Deployer not found: github 或者 Deployer not found: git 原因是还需要安装一个插件： 1npm install hexo-deployer-git --save 其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey). 打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会： 4.9. 保留CNAME、README.md等文件提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的： 由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。 4.10. 常用hexo命令常见命令 1hexo new \"postName\" #新建文章2hexo new page \"pageName\" #新建页面3hexo generate #生成静态页面至public目录4hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）5hexo deploy #部署到GitHub6hexo help # 查看帮助7hexo version #查看Hexo的版本 缩写： 1hexo n == hexo new2hexo g == hexo generate3hexo s == hexo server4hexo d == hexo deploy 组合命令： 1hexo s -g #生成并本地预览2hexo d -g #生成并上传 4.11. _config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。 需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 4.12. 写博客定位到我们的hexo根目录，执行命令： 1hexo new 'my-first-blog' hexo会帮我们在_posts下生成相关md文件： 我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： 当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。 一般完整格式如下： 1---2title: postName #文章页面上的显示名称，一般是中文3date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改4categories: 默认分类 #分类5tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格6description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面7---89以下是正文 那么hexo new page 'postName'命令和hexo new 'postName'有什么区别呢？ 1hexo new page \"my-second-blog\" 生成如下： 最终部署时生成：hexo\\public\\my-second-blog\\index.html，但是它不会作为文章出现在博文目录。 4.12.1. 写博客工具那么用什么工具写博客呢？这个我还没去找，以前自己使用editor.md简单弄了个，大家有好用的hexo写博客工具可以推荐个。 4.12.2. 如何让博文列表不显示全部内容默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？ 答案是在合适的位置加上&lt;!--more--&gt;即可，例如： 1# 前言23使用github pages服务搭建博客的好处有：451. 全是静态文件，访问速度快；62. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；73. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；89&lt;!--more--&gt;10114. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；125. 博客内容可以轻松打包、转移、发布到其它平台；136. 等等； 最终效果： 最终效果可以访问我的git博客来查看效果： http://mygit.me 不过呢，其实这个博客我只是拿来玩一玩的，没打算真的把它当博客，因为我已经有一个自己的博客了，哈哈！正因如此，本文仅限入门学习，关于hexo搭建个人博客的更高级玩法大家可以另找教程。 参考http://www.cnblogs.com/zhcncn/p/4097881.html http://www.jianshu.com/p/05289a4bc8b2","link":"/2021/09/16/hexo%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"},{"title":"mysql性能优化（内部培训笔记）","text":"mysql性能优化方案存储引擎InnoDB：事务安全、行级锁定、主键索引、支持外键（5.7版本的默认存储引擎，推荐） CSV：表格 Archive：日志系统、历史数据、大量的设备数据采集 Memory：redis，查找热度比较高的数据 MyISAM:5.5以前的默认版本 Federated:分布式、远程获取数据（远程表） 索引排序，随机io变有序io 适合大中型表 MySQL中使用的是B+Tree：所有数据存在叶子节点，左闭合 优化建议：索引列的数据长度能少则少；不一定越多越好；覆盖索引，少用select *；列的离散性要好 explain 执行计划 锁","link":"/2019/12/11/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%86%85%E9%83%A8%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0%EF%BC%89/"},{"title":"工作流设计","text":"7个方面总结：审批工作流设计工作流是后台系统的核心和灵魂，而审批则是工作流中的最基础的应用场景。在公司管理和运转中引入审批工作流，替代原本的纸质申请和审批，可以达到以下目标： 提高公司的运转效率 公司管理制度规范化 系统留档，便于追溯 环保 本文将从角色、内容、流程、动作、权限、配置、效率7个方面，对审批工作流的产品设计进行总结。 一. 角色 在一个公司中，每个人都会有自己的岗位职责和层级之分，不同的岗位和层级定位不一样，需要完成的任务也不一样。在审批流程中，我们只抽象划分为两类： 角色1：发起人 审批的发起人需要完成的主要是事务性、操作性的工作，同时也是一个审批流程的Owner，是最关心审批进展的人。因此在发起人的角度，在创建完审批事项后，还需要完善相关信息、催促审批人及时审批、处理驳回修改意见、重新提交等。发起人角度设计的要点总结如下： 兼容统一发起入口和业务场景触发 常用的审批事项要方便找到 有统一汇总的审批管理页面 角色2：审批人 审批人在流程中需要完成的主要是决策性的工作，因此在审批人的视角，内容和操作都应该尽量精简： 只看到最重要的信息，避免信息过多影响判断 只进行必要操作，不能有过多选择或过多输入，影响决策效率 统一的页面进行审批操作和管理 需要有审批历史，以便追溯 二. 内容 \\1. 提炼最小集合 根据审批事项的不同，需要流转的内容也是不同的。对于审批流程的设计来说，需要在实际业务中提炼出最核心的内容，一则可以减轻发起人的工作负担（发起一个审批要填一堆的资料相信没人会开心），二则可以提高决策的准确性和效率。 例如一个请假审批流程，核心就是请假时间、事由和请假类型；而一个立项投决的审批，则需要重点展示立项会的表决结果，同时还需要把会议记录做为附件带上，以便在必要时可以查看，在交互上，这里同样需要注意内容的归类、收纳。 设计要点总结如下： 内容尽可能精炼 有些内容是必要的，但系统可以自行获取就不要让发起人再输入一遍 预置常用的内容，用选择的方式替代输入的方式，同时也提高了内容的规范性 \\2. 查看和修改 在审批的过程中，有时候需要让不同的审批人查看不同的内容，且限定有些人有修改权限而有些人只有只读权限，这都会在后面的“权限”里总结。 三. 流程 1. 自主选定审批人流程 这是一种比较轻量、灵活的审批流程形式，适用于公司规模不大、流程没有标准化的情况。要点是发起人发起一个审批事项并提交时，需要自行选择下一个环节的审批人。而下一个环节的审批人审批通过后，可以选择继续流转到再下一个人去审批，或者结束这个流程。 \\2. 串行流程 串行流程就是每一个审批环节的人审批通过后，才会进入到下一个环节。每个环节的驳回，可以根据业务需要，设计成驳回到发起人、驳回到上一个环节或驳回到指定环节重新审批，或兼而有之，做为选项供审批人选择。 \\3. 并行流程 并行流程是一个审批环节需要几个人或角色审批通过才算通过，可以有以下两种方式： 任意一个人审批通过即进入下一环节 必须所有人审批通过才进入下一环节 上述第一个方式比较好理解，第二个方式和串行流程容易混淆，即同样是要多个人审批，到底是一个接一个、还是同时通过才算通过？到底用哪种方式，区别是审批人是不是同一个级别，并行的方式其实类似于同级别的会签，而串行方式适合有上下层级关系的情况。 并行流程的驳回则相对简单，一般是设计成有一个人驳回则该环节即算驳回。 \\4. 条件触发流程 条件触发流程在审批工作流中也比较常见，设计上就是某个审批环节要由谁/或哪个角色审批，需要取决于条件判断。例如金额低于1万元由财务总监审批通过后即结束，金额在1万元以上则由副总裁审批通过后即结束。 \\5. 混合流程 混合流程顾名思义就是混合了以上几种流程，还是以上述金额审批为例，我们修改成：金额低于1万元的，由财务审批通过后即结束；金额在1万元到10万元的，需要先由财务审批，之后交由副总裁审批通过后即结束；金额高于10万元的，需要由董事长和总裁一同审批通过后才结束。 四. 动作 \\1. 通过 通过动作由审批人操作，是否需要输入通过原因、通过原因是否必填需要根据实际业务情况决定。要点总结如下： 简单申请不需要填写通过原因，或者原因选填 通过原因需要填的话，可用于反馈或激励发起人的情况 \\2. 驳回修改 驳回修改动作由审批人操作，和通过不同，为了让发起人知道如何修改，驳回原因一般需要设定成必填项，否则发起人或上一个审批环节的人不知道为何被驳回、以及要如何修改。 驳回修改可根据业务需要，在以下逻辑中选择： 驳回到发起人 驳回上一环节 驳回到选定的之前的某个审批环节 \\3. 重新提交 重新提交由发起人操作，和驳回修改是一一对应的。设计上要注意，审批人审批重新提交的内容时，需要附带上一次驳回修改的原因。 \\4. 取消 取消动作可选，一般来说是发起人取消，而不是审批人取消，原因如下： 审批人只关心一个审批事务过来后，判断并决策是通过还是驳回 取消和驳回含义容易混淆，区分不开 在设计上，我们还可以做到发起人是否可取消可由配置项进行配置。 五. 权限 权限的控制贯穿在审批流程的方方面面，上述的角色、内容、流程和动作都会涉及到权限的控制。权限体系的设计是一个大工程，在审批流程中，采用基于角色的访问控制体系（RBAC）是一个不错的选择： “基于角色的访问控制体系，包括用户、角色、目标、操作、许可权五个基本数据元素，每个角色至少具备一个权限，每个用户至少扮演一个角色，可以对完全不同的角色分配完全相同的访问权限，用户和角色是多对多的关系。” 设计要点总结如下： 操作和许可权内容，可区分为功能权限和数据权限 什么人可以发起什么审批，由功能权限控制 什么人/角色在整个审批流程中可见什么数据，由数据权限控制 什么人/角色可以审批什么环节，由独立的审批配置控制，下一节会进行阐述 关于权限可以参考笔者另一个篇文章：面向中小企业SaaS的权限管理系统 六. 配置和扩展性 审批工作流的配置灵活度和开发复杂度成反比，具体要灵活到什么程度，需要由业务需求决定。一般针对公司开发的中后台系统，灵活性相对较少，而面向多个公司的商业化的系统，则灵活性要求大大提高。配置的灵活性体现在以下方面： 审批流程的类型可修改 具体的审批环节可增删改 各个环节审批人/角色可配置 审批相关的权限可变更 七. 效率 工作流的核心目标是提高企业运行效率，如果线上审批流程效率还不如原来的纸质操作，那这个流程的设计就是失败的，也失去了意义。因此，在完成整个审批流程的设计之后，我们还需要花大精力对流程的效率进行审视和优化。对于审批流程效率的提升，总结的经验点如下： 审批的操作尽可能精简，且操作含义明确 只要求输入必要的表单 待审批事项及时通知到审批人 审批进展及时通知发起人 发起人可选择主动催促审批人 做好下一步操作的引导 总结 审批流程是中后台工作流的基础应用，我们在设计的过程中，把握的核心要点是“提高效率，规范管理”，在设计过程中要时时回头审视，以免脱离了这个最重要的目标。","link":"/2021/09/17/%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%AE%BE%E8%AE%A1/"},{"title":"工作流程引擎","text":"0、为什么要使用工作流引擎假定我们有一个支付订单状态需要维护，它的状态图如下： 它的状态跃迁自左向右，清晰名了，而且没有处理角色的概念，此时我们使用代码控制好状态流转即可，无需使用框架。 再来看另外一个场景，假定我们有一个企业内部采购订单，它的状态图如下： 这个采购订单的状态复杂多变，状态的转换不稳定性很强，随时有可能增加新的状态；而且不同状态的处理人也是不同的，存在权限管理功能，若此时我们仍然使用一个状态字段来维持状态变更，无疑会困难重重。 工作流引擎就是为了解决这类问题而生的，我们可以观察当前实体(如支付订单、采购订单)是否具有如下特性，由此来确定是否需要引入工作流引擎。 状态的个数及其稳定性，个数多且不稳定，适合使用工作流引擎。 每个状态的处理人，处理人角色多且不稳定，适合使用工作流引擎。 工作流引擎实际上是放大了状态管理的功能，它根据既有流程图（基于 BPMN2.0 规范）的指示，指定每一次状态跃迁的处理角色，在状态变更时持久化评论、表单、附件等数据，保存了完整处理轨迹。 工作流引擎最常见用于审批流程中，现在一线互联网公司也开始使用，并有快速推广的趋势，复杂繁多的业务流程如果采用 if else 实现那将是崩溃的，代码不可维护，业务流程在代码中可读性很差，所以高人设计了业务流程模型图示 BPMN2.0 规范，我们要做到就是把业务场景抽象为标准流程图，把流程图丢到流程引擎中按流程定义约定逐步流转，很显然扩展性和业务可描述性会好很多，所以工作流引擎主要用于解决复杂的业务，目前经常被提起的中台系统抽象业务为服务，也涉及大量智能的业务流程引擎做支撑。 1、工作流概念1.1 流程的定义从最朴素和最直接的角度看，我们按照条理和顺序做事情的过程，就是流程。 流程之父迈克尔.哈默是这样定义的： 流程是把一个或多个输入转化对顾客有价值的输出的活动。 李.克拉耶夫斯基和拉里.里茨曼在其《运营管理–流程与价值链》第 7 版中是这样定义的： 流程是一种或一组活动，这些活动利用一个或多个输入要素，对起进行转换并 3 使其增值，向顾客提供一种或多种产出。 我们的理解是： 流程就是一组活动按照一定的顺序组成的序列流，其顺序可能是串行的、并行的，或者两者的组合模式，例如面包制作流程中的“混合原料”，“揉面醒发”，“整形”，“烘烤”等活动。 综上所述，流程一般具备六个要素：输入、活动、活动间的相互作用、输出、流程的服务对象和价值。 如下图所示： 1.2 工作流参考模型1993 年，工作流管理联盟（WfMC）成立，接着发布了著名的工作流参考模型（如下图所示）及接口规范。2002 年 10 月 25 日，WFMC 发布了 XPDL 1.0 规范(WFMC-TC-1025)、规范流程定义的 XML 描述形式。 WFMC 定义的 5 类接口的功能： 接口 1：过程定义输入输出接口，工作流服务和工作流建模工具间接口，包括工作流模型的解释和读写操作； 接口 2：客户端函数接口，工作流服务和客户应用之间的接口，这是最主要的接口规范，它约定所有客户方应用与工作流服务之间的功能操作方式； 接口 3：激活应用程序接口，工作流机和直接调用的应用程序之间的直接接口； 接口 4：工作流执行服务之间的互操作接口，工作流系统之间的互操作接口； 接口 5：系统管理与监控接口，工作流服务于工作流管理工具之间的接口； 1.3 主要应用场景 一般 OA 都内置有一个轻量级的审批流引擎，适用于办公协同领域。BPM 呢，在中国主要适用于流程化信息化程度较高的制造业、零售业、房地产、金融业和政府事业单位，可以应用在企业战略、运营、管理等从上到下的各个场景。BPM 主要为这些行业中体量较大的公司客户服务。 2、 工作流规范简介20 世纪 70 年代中期，工作流出现并运用于办公自动化领域，使流程管理技术第一次有了系统的技术规范。20 世纪 80 年代 初期，工作流伴随着 OA 系统走向商用，但是应用范围有限。至 80 年代后期，OA 系统的研究被群件和工作流管理系统所代替。20 世纪 90 年代以后，相关技术逐渐成熟，工作流管理联盟(WfMC)成立并发布了工作流参考模型。进入 21 世纪， BPM 更进一步发展。SOA 的出现使得流程管理技术从工作流转向业务流，基于此的一系列规范也相应被推出。 发展到目前，BPMN 规范最完善，现在主流工作流引擎产品，大多基于 BPMN2.0 规范实现的，这里只介绍 BPMN2.0 规范。 2.1 BPMN2.0 规范业务流程模型和标记法（BPMN, Business Process Model and Notation）是一套图形化表示法，用于以图形的方式详细说明各种业务流程。 它最初由业务流程管理倡议组织（BPMI, Business Process Management Initiative）开发，名称为”Business Process Modeling Notation”，即“业务流程建模标记法”。BPMI 于 2005 年与对象管理组织（OMG, Object Management Group）合并。2011 年 1 月 OMG 发布 2.0 版本（时至今日，没人会用 1.0 版本了），同时改为现在的名称。 BPMN2.0 规范的实现，实质上是一个按照特定规范编写的 XML 文件，使用特定的 BPMN 设计器，即可以图形化的形式查看和编辑该文件。Camunda，Activiti，Flowable 等主流的 java 开源流程引擎，以代码的形式实现了这套图形化表示法，使任务的流转依赖图形，而非具体的实现代码。 UML vs BPMN UML 和 BPMN 之间唯一的正式关系是 OMG 维护两个开放标准。 UML(统一建模语言)作为一种可视化的建模语言，其中的活动图也适用于流程建模，但其支持深度不够。 BPMN 诞生时间晚于 UML，据称从某种意义上讲，UML Activity Diagrams 是 BPMN 的一个子集，也是 BPMN 的历史前身。 BPMN2.0，流程主要涉及的对象： 如上图所示，BPMN2.0 规范主要包含了三个部分 Activities(活动)、Gateway(网关)、Event(事件)。 下图在线流程设计器，设计的流程图效果如下： 2.2 流程技术发展历史流程管理思想及方法论的发展，深刻影响着流程技术的发展，而流程技术的发展也反过来促进了流程管理思想的发展，二者相辅相成，互相促进。流程技术的发展大概经理了三个发展阶段： 工作流技术阶段 工作流技术在以“信息技术驱动的技术流程自动化”管理思想为主导的时代进入了新的热潮。此阶段的主要技术是 OO 技术、Web 1.0 及 ERP、OA 等，而 ERP 及 OA 都是基于工作流技术的应用。 BPM 技术阶段 在“业务流程为主导的管理思想”时期，业务流程管理系统/套件（BPMS）出现了，BPMS 所要解决的问题是怎么以业务流程为中心全面串联企业的经营活动。要达到这个目标，首先要全面梳理和设计企业的所有业务流程，最终通过 BPMS 进行落地实现。在这个时期，出现了 Web 服务，SOA 和 ESB（企业服务总线）等技术。 BPM 治理阶段 为了提高 BPM 实施的成功率及投资回报率而引入了一些新的管理思想和技术，这些管理思想及技术终极目标还是围绕 BPM 的。 流程规范、技术进展技术路线图 3、工作流和 BPM 的区别啥叫 BPM，来点小科普。讲 BPM，我们首先就要清楚什么叫业务流程，或者说什么是业务，然后才能明白什么叫业务流程管理。 业务流程简单来说就是业务处理流，或者说业务的流转过程。这里重要的不是“流程”二字，而是“业务”二字。注意，类似于请假不能算是企业的“业务”。例如，你去见一个新客户，客户问你，你的公司主要做什么业务？你总不能说我们公司是做“请假”业务的吧？那么到底业务流程关注的是什么样的业务呢？一句话，对顾客产生价值的流程就是我们这里所关注的“业务流程”。 产品和服务的设计与开发 产品和服务的市场营销与销售 产品和服务的交付 客户服务管理 业务流程管理是一种以规范化地构造端到端的卓越业务流程为中心，以持续地提高组织业务绩效为目的的系统化管理方法。 3.1 定义不同工作流系统是指通过电子版代替纸质版帮助企业处理所有内部事务，实现各种审批工作，支持协同工作中的一部分。 BPM 系统即业务流程是指企业、政府以及其它各种组织,为了达到其业务目标,利用技术实现业务自动化，协助企业业务发展。 3.2 流程架构不同工作流系统是从企业内部出发，单一只对企业本部门或者本业务的业务需求，部门与部门之间流程无法衔接，信息的共享和传递困难，存在大量流程断点。 而 BPM 系统可以实现各流程之间可以衔接、协调，避免了流程孤岛的产生。同时，在激烈的市场竞争环境下，对提高整个业务流程运行的效率、成本、等满足客户的需求。 3.3 应用不同工作流系统是为帮助企业解决“办公自动化”、“流程自动化”而诞生的应用技术，却不对业务流程进行优化的，功能较单一。 而 BPM 系统可以对业务全过程进行管理，如分析，整合、协助等，确保工作流能够按计划实施。 3.4 集成功能不同工作流系统只能对单一业务进行处理。 BPM 可以帮助软件开发人员来集成第三方的应用软件。例如 ERP、PLM、财务软件等可以通过 BPM 平台进行集成。 3.5 流程的持续改进不同工作流系统由于业务人员对其缺少认识和关注，及工作流系统本身缺少对内部业务的连接，因此很难对流程进行持续改进。 而 BPM 系统由于可以帮助业务人员密切关注信息系统内嵌流程与其它业务流程衔接关系，可以及时进行流程的调整、改进等，最终是为了优化、提升和自动化处理业务流程。 总之，随着信息技术的高速发展，业务不断扩大，工作流技术一直是企业信息化建设不可或缺的一部分。不管是办公自动化 OA 系统，还是企业 ERP 系统的部署，利用工作流系统和 BPM 系统都是可以提高企业运行效率的。 4、市场上工作流厂商分类只提供工作流产品。这类厂商产品单一，尽管产品质量能够得到保证，但是发展最为困难。技术在这里不是第一竞争力。 提供工作流产品和快速开发平台。这类厂商在工作流的基础上提供开发框架进一步简化编程，相比第一类厂商会更有竞争力，但是其发展受到系统集成商的限制。 提供工作流产品和业务套件/平台，同时自己接项目。与单纯的快速开发平台相比，业务平台显然站在了一个更高的层次上。在软件开发中，最大的浪费往往并不在于技术本身，而是在于对业务的不熟悉，在于核心领域模型的频繁变动。对用户而言，根据需要选择合适业务平台和相关服务无疑能够产生最大的价值。这是目前生存状态比较好的厂商，多是老牌厂商或是有充足的资金。业务套件/平台能够给用户提供最大的价值。在任何时候，直接面对最终用户就是王道。 工作流厂商的机会在哪里？ 最重要的就是，将产品面向最终用户。 提供行业应用业务套件。能够做到对某类应用的快速实施，很多功能能够做到开箱即用。 转向 BPMS。这个需要两方面的努力：一是业务方面需要与业务流程咨询公司进行合作；二是产品需要增加 BPMS 特性。 自己做项目。大公司靠财务，小公司靠销售。 5、流程引擎发展趋势5.1 趋势一：中台化对于信息化软件的演进，从流程线和开发部署方式两条线来看，分别从轻到重和从重到轻发展，交汇于数字中台。从部署 开发一线来看，传统的开发部署模式时间长、成本高、系统割裂，不能满足企业实现“成本效益”的需求，因而数字中台 转型成为必然的选择。 5.2 趋势二：低代码需求端的 复杂多变对软件开发提出了新的要求，市场要求软件的开发的速度越快越好、交付时间越来越短，“低代码”应运而生。 BPM 在未来也将充分与低代码相结合，BPM 的低代码化主要包含设计端的应用。开发人员寻找通用的开发活动，然后为 所有环节构建一个基本代码并将它们封装在某个可视化的模块里。基于这些模块，业务人员就可以通过拖拉拽的方式，在 可视化的设计器上像“搭积木”一样，对表单、流程和应用进行搭建。这种方式极大地提高了软件开发的敏捷性，同时实 现了“以客户为中心”，使公司更好的响应市场。 5.3 趋势三：智能化业务流程管理（BPM）已成为企业内部优化的选择。流程的优化通过节省时间并降低成本为公司带来竞争优势，使员工更 有效地工作。随着市场的成熟度日益提高，各种新兴技术不断发展，BPM 自身也需要与时代结合，不断发展。未来 BPM 将进一步与 RPA（机器人流程自动化）、AI（人工智能）等智能化技术相结合，为企业提供更敏捷、优质的服务。 6、开源流程引擎目前 java 主流的开源流程引擎，有 jBPM，Activiti，Camunda，Flowable 等。","link":"/2021/09/16/%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E/"},{"title":"开篇","text":"长风破浪会有时，只怪云帆济沧海 自己本人卢希强，别名小希，28岁，居住在武汉，一个2015年毕业的软件开发工程师，四年多时间沉心工作，职业搬砖，知识零碎，回头皆空。兴趣爱好广泛，一切运动、唱歌、游戏……无奈时间不允许。回归近三十年人生路，波澜不惊，平平淡淡，车房都有，即将结婚。特开博客记录生活工作点滴。 生活 不求大富大贵，但求平安风顺 结婚在即，奔三冲刺，平平安安才是真。 工作 Stay hungry, stay foolish 专职于iOS开发，四年半开发经验，工作之余接触关于web端的相关知识。感觉技术日新月异，不往前便落后，所以坚持学习、坚持笔记、坚持coding吧。 目标 先定个小目标，赚他个一个亿？ 1、学习flutter,copy一个完整的公司项目； 2、减肥30斤； 3、学习SwiftUI、vue等； 4、每月一本书； 5、赚钱赚钱。 最后 会当凌绝顶，一览众山喜爱 祝自己工作顺利，升职加薪，生活幸福，股市长虹！ 2020为了生活，冲鸭！","link":"/2019/12/02/%E5%BC%80%E7%AF%87/"},{"title":"微服务知识体系","text":"SpringCloud资料微服务资料目录目录…………………………………………………………………………………………………………………….. 2 1 SpringCloud简介………………………………………………………………………………………………. 1 1.1 什么是微服务…………………………………………………………………………………………………… 1 1.2 CAP定理…………………………………………………………………………………………………………… 1 1.3 微服务架构图…………………………………………………………………………………………………… 2 1.4 SpringCloud Netflix………………………………………………………………………………………………. 7 1.5 Spring Cloud Alibaba…………………………………………………………………………………………… 10 1.6 微服务之间的通讯…………………………………………………………………………………………… 10 1.7 主流微服务注册中心浅析和对比………………………………………………………………………… 10 1.8 单体优先还是微服务？…………………………………………………………………………………….. 11 2 微服务框架……………………………………………………………………………………………………. 11 2.1 参考微服务文件结构………………………………………………………………………………………… 11 2.2 服务划分……………………………………………………………………………………………………….. 16 **** 1 SpringCloud简介1.1 什么是微服务微服务架构是一个分布式系统，按照业务进行划分成为不同的服务单元，解决单体系统性能等不足。 微服务是一种架构风格，一个大型软件应用由多个服务单元组成。系统中的服务单元可以单独部署，各个服务单元之间是松耦合的。 1.2 CAP定理CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。 一致性（C**）：**在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本） 可用性（A**）：**在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性） 分区容忍性（P**）：**以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。 CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时C和P两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足。因此在进行分布式架构设计时，必须做出取舍。 Zookeeper**和Consul保证的是CP，而Eureka则是AP，Nacos不仅支持CP也支持AP**。 1.3 微服务架构图1.3.1 Eurake微服务架构图1 1.3.2 Eurake微服务架构图2https://www.processon.com/view/5b7d2f1fe4b075b9fe22d3d2?fromnew=1 1.3.3 Eurake微服务架构图3https://www.processon.com/view/5ed36dd5e401fd0735a531cd?fromnew=1 1.3.4 Alibaba微服务架构图4https://www.processon.com/view/5db03daee4b0e433944b5a68?fromnew=1 1.3.5 Alibaba微服务架构图5https://www.processon.com/view/60c18dcbe401fd34a14ea35a?fromnew=1 1.3.6 Alibaba微服务架构图6https://www.processon.com/view/5dc2c0ffe4b0e433945eefe9?fromnew=1 https://www.processon.com/view/60e503da0e3e745f07eb05aa?fromnew=1 https://www.processon.com/view/5fbc7ad8e401fd2d6ed50d8f?fromnew=1 1.4 SpringCloud Netflix微服务架构的逻辑结构组成，包括各种微服务、注册发现、服务网关、熔断器、统一配置、跟踪服务等。 1.4.1 FeignFeign(接口调用)：微服务之间通过Rest接口通讯，Spring Cloud提供Feign框架来支持Rest的调用，Feign使得不同进程的Rest接口调用得以用优雅的方式进行，这种优雅表现得就像同一个进程调用一样。 1.4.2 EurekaNetflix eureka(注册发现)：微服务模式下，一个大的Web应用通常都被拆分为很多比较小的web应用(服务)，这个时候就需要有一个地方保存这些服务的相关信息，才能让各个小的应用彼此知道对方，这时就需要在注册中心进行注册。 每个应用启动时向配置的注册中心注册自己的信息（ip地址，端口号, 服务名称等信息），注册中心将他们保存起来，服务间相互调用的时候，通过服务名称就可以到注册中心找到对应的服务信息，从而进行通讯。 注册与发现服务为微服务之间的调用带来了方便，解决了硬编码的问题。服务间只通过对方的服务id，而无需知道其ip和端口即可以获取对方方服务。 1.4.3 RibbonRibbon(负载均衡)：Ribbon是Netflix发布的负载均衡器，它有助于控制HTTP和TCP客户端的行为。为Ribbon配置服务提供者的地址列表后，Ribbon就可基于某种负载均衡算法，自动地帮助服务消费者去请求。 Ribbon默认为我们提供了很多的负载均衡算法，例如轮询、随机等。当然，我们也可为Ribbon实现自定义的负载均衡算法。 在SpringCloud中，当Ribbon与Eureka配合使用时，Ribbon可自动从EurekaServer获取服务提供者的地址列表，并基于负载均衡算法，请求其中一个服务提供者的实例 （为了服务的可靠性，一个微服务可能部署多个实例） 1.4.4 HystrixHystrix(**熔断器)**：当服务提供者响应非常缓慢，那么消费者对提供者的请求就会被强制等待，直到提供者响应或超时。 在高负载场景下，如果不做任何处理，此类问题可能会导致服务消费者的资源耗竭甚至整个系统的崩溃（雪崩效应），Hystrix正是为了防止此类问题发生。 Hystrix是由Netflix开源的一个延迟和容错库，用于隔离访问远程系统、服务或者第三方库，防止级联失败，从而提升系统的可用性与容错性。 Hystrix**主要通过以下几点实现延迟和容错：** 包裹请求：使用HystrixCommand（或HystrixObservableCommand）包裹对依赖的调用逻辑，每个命令在独立线程中执行。这使用了设计模式中的“命令模式”。 跳闸机制：当某服务的错误率超过一定阈值时，Hystrix可以自动或者手动跳闸，停止请求该服务一段时间。 资源隔离：Hystrix为每个依赖都维护了一个小型的线程池（或者信号量）。如果该线程池已满，发往该依赖的请求就被立即拒绝，而不是排队等候，从而加速失败判定。 监控：Hystrix可以近乎实时地监控运行指标和配置的变化，例如成功、失败、超时和被拒绝的请求等。 回退机制：当请求失败、超时、被拒绝，或当断路器打开时，执行回退逻辑。回退逻辑可由开发人员指定。 1.4.5 ZuulZuul(微服务网关) ：不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求。 例如一个电影购票的手机APP，可能调用多个微服务的接口才能完成一次购票的业务流程 如果让客户端直接与各个微服务通信，会有以下的问题： 1、客户端会多次请求不同的微服务，增加了客户端的复杂性。 2、存在跨域请求，在一定场景下处理相对复杂。 3、认证复杂，每个服务都需要独立认证。 4、难以重构，随着项目的迭代，可能需要重新划分微服务。 例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将很难实施。 某些微服务可能使用了对防火墙/浏览器不友好的协议，直接访问时会有一定的困难。 以上问题可借助微服务网关解决。微服务网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过微服务网关。 使用微服务网关后，微服务网关将封装应用程序的内部结构，客户端只用跟网关交互，而无须直接调用特定微服务的接口。 这样，开发就可以得到简化。不仅如此，使用微服务网关还有以下优点： 易于监控。可在微服务网关收集监控数据并将其推送到外部系统进行分析。 易于认证。可在微服务网关上进行认证，然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。 减少了客户端与各个微服务之间的交互次数。 1.4.6 ConfigSpring cloud Config（ 统一配置服务）：对于传统的单体应用，常使用配置文件管理所有配置。 例如一个SpringBoot开发的单体应用，可将配置内容放在application.yml文件中。如果需要切换环境，可设置多个Profile，并在启动应用时指定spring.profiles.active={profile}。 然而，在微服务架构中，微服务的配置管理一般有以下需求： 集中管理配置。一个使用微服务架构的应用系统可能会包含成百上千个微服务，因此集中管理配置是非常有必要的。 不同环境，不同配置。例如，数据源配置在不同的环境（开发、测试、预发布、生产等）中是不同的。 运行期间可动态调整。例如，可根据各个微服务的负载情况，动态调整数据源连接池大小或熔断阈值，并且在调整配置时不停止微服务。 配置修改后可自动更新。如配置内容发生变化，微服务能够自动更新配置。 综上所述，对于微服务架构而言，一个通用的配置管理机制是必不可少的，常见做法是使用配置服务器管理配置。 Spring cloud bus利用Git或SVN等管理配置、采用Kafka或者RabbitMQ等消息总线通知所有应用，从而实现配置的自动更新并且刷新所有微服务实例的配置。 1.4.7 ZipkinSleuth+ZipKin(跟踪服务)：Sleuth和Zipkin结合使用可以通过图形化的界面查看微服务请求的延迟情况以及各个微服务的依赖情况。 需要注意的是Spring boot2及以上不在支持Zipkin的自定义，需要到官方网站下载ZipKin相关的jar包。 1.5 Spring Cloud AlibabaNacos**：**一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 Sentinel**：**把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 RocketMQ**：**开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。 Dubbo**：**这个就不用多说了，在国内应用非常广泛的一款高性能 Java RPC 框架。 Seata**：**阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 Arthas**：**开源的Java动态追踪工具，基于字节码增强技术，功能非常强大。 1.6 微服务之间的通讯1.6.1 同步REST HTTP 协议、RPC TCP 协议。 1.6.2 异步消息中间件，常见的消息中间件有 Kafka、ActiveMQ、RabbitMQ、RocketMQ ，常见的协议有 AMQP、MQTTP、STOMP、XMPP。 1.7 主流微服务注册中心浅析和对比https://developer.aliyun.com/article/698930 Nacos Eureka Consul CoreDNS Zookeeper 一致性协议 CP+AP AP CP — CP 健康检查 TCP/HTTP/MYSQL/Client Beat Client Beat TCP/HTTP/gRPC/Cmd — Keep Alive 负载均衡策略 权重/metadata/Selector Ribbon Fabio RoundRobin — 雪崩保护 有 有 无 无 无 自动注销实例 支持 支持 不支持 不支持 支持 访问协议 HTTP/DNS HTTP HTTP/DNS DNS TCP 监听支持 支持 支持 支持 不支持 支持 多数据中心 支持 支持 支持 不支持 不支持 跨注册中心同步 支持 不支持 支持 不支持 不支持 SpringCloud集成 支持 支持 支持 不支持 不支持 Dubbo集成 支持 不支持 不支持 不支持 支持 K8S集成 支持 不支持 支持 支持 不支持 1.8 单体优先还是微服务？https://zhuanlan.zhihu.com/p/52638618 1.9 监控服务 1.9.1 Nacoshttp://localhost:8001/nacos 1.9.2 SkyWalking可以从http://skywalking.apache.org/downloads下载apache-skywalking-apm-$version.tar.gz包。 skywalking提供了一个可视化的监控平台，安装好之后，在浏览器中输入(http://localhost:8080 (opens new window))就可以访问了。 配置vm参数-idea配置vm参数 -javaagent:D:\\20.Vue\\apache-skywalking-apm-bin\\agent\\skywalking-agent.jar -Dskywalking.agent.service_name=febs-gateway -Dskywalking.collector.backend_service=localhost:11800 1.9.3 Knife4jhttps://localhost:8301/doc.html 1.9.4 Spring Boot Adminhttp://localhost:8401/applications 1.9.5 TxManagerhttp://localhost:8501/admin/index.html#/ 1.10 分布式事务LCN – TM (服务端server ) + TC ( 客户端-spring-boot 使用）LCN基本实现原理 1.发起方与参与方都与我们的LCN管理器一直保持长连接； 2.发起方在调用接口之前，先向LCN管理器申请一个全局的事务分组id； 3.发起方调用接口的时候在请求头中传递事务分组id； 4.参与方获取到请求头中有事务分组的id的，则当前业务逻辑执行完实现假关闭，不会提交或者回滚当前的事务。 5.发起方调用完接口后，如果出现异常的情况下，在通知给事务协调者回滚事务，这时候事务协调则告诉给参与方回滚当前的事务。 https://blog.csdn.net/qq_41463655/article/details/104996363 https://juejin.cn/post/6844904127865208839 1.11 参考项目资料https://gitee.com/log4j/pig https://gitee.com/matevip/matecloud https://gitee.com/mrbirdd/FEBS-Cloud?_from=gitee_search 2 微服务框架2.1 参考微服务文件结构2.1.1 SpringBlade 2.1.2 Pig微服务结构 2.1.3 BIM 项目微服务文件结构├─base // 基础依赖库 │ ├─common │ ├─message-help-starter │ ├─message.help │ ├─security.client │ ├─server.core │ └─server.support ├─database // 数据库相关配置 ├─logs ├─requests │ └─config-servers └─servers // 服务包 ├─batch.model // 模型服务(BIM业务的) │ ├─res │ ├─src ├─business-server // 项目业务服务目录 │ ├─er │ ├─server-api-bpm // bpm流程api服务 │ │ └─src │ ├─server-business // 项目服务 │ │ ├─configDev │ │ ├─configPro │ │ ├─configTest │ │ ├─sql │ │ ├─src │ ├─server-doc // 档案服务 │ │ ├─configDev │ │ ├─configPro │ │ ├─configTest │ │ └─src │ ├─server-labour // 劳务管理 │ │ ├─configDev │ │ ├─configPro │ │ ├─configTest │ │ └─src │ ├─server-news // 新闻管理 │ │ ├─configDev │ │ ├─configPro │ │ ├─configTest │ │ ├─src │ ├─server-quality // 质量管理 │ │ ├─doc │ │ ├─sql │ │ └─src │ ├─server-safety // 安全管理 │ │ ├─configDev │ │ ├─configPro │ │ ├─configTest │ │ ├─src │ ├─server-schedule │ │ ├─configDev │ │ ├─configPro │ │ ├─configTest │ │ ├─src │ ├─server-site // 现场管理 │ │ ├─configDev │ │ ├─configPro │ │ ├─configTest │ │ └─src │ └─server-steel │ ├─configDev │ ├─configPro │ ├─configTest │ └─src ├─server-cost // 合同与产值 │ ├─configDev │ ├─configPro │ ├─configTest │ ├─docs │ ├─src ├─funcs // 支撑性功能，旧项目移植过来，可以归到base │ ├─fastdfs │ ├─fastdfs-client-java │ ├─tus.upload │ └─video.ffmpeg ├─starters // starter（自定义的一些starter） │ ├─fastdfs-spring-boot-starter │ └─server.file // 文件服务，可以当到 sys-manage-center └─sys-manage-center // 框架性微服务 ​ ├─api-gateway // 网关服务 ​ │ ├─configDev ​ │ ├─configPro ​ │ ├─configTest ​ │ ├─src ​ ├─auth-center // 授权服务 ​ │ ├─configDev ​ │ ├─configPro ​ │ ├─configTest ​ │ ├─docs ​ │ ├─src ​ ├─bpm-center // 流程服务 ​ │ ├─configDev ​ │ ├─configPro ​ │ ├─configTest ​ │ ├─docs ​ │ ├─sql ​ │ ├─src ​ ├─config // 配置中心 ​ │ ├─configDev ​ │ ├─configPro ​ │ ├─configTest ​ │ ├─src ​ ├─register // 注册中心 ​ │ ├─configDev ​ │ ├─configPro ​ │ ├─configTest ​ │ ├─src ​ └─user-center // 用户中心 ​ ├─configDev ​ ├─configPro ​ ├─configTest ​ ├─doc ​ ├─sql ​ ├─src 原来规划了一个api层但是common里面要统一实体，维护起来很麻烦，就没维护了 各服务数据库隔离，原则上不允许跨库跨模式查询 2.1.4 Ebid 电子招投标项目微服务文件结构 2.2 服务划分2.2.1 服务划分微服务的划分方法，常见的是两种，按业务能力和按子域。有的观点，认为两种划分可以根据不同的情况进行选择。而有的观点，认为应该这样划分而不要那样划分。 “子域”，就是DDD中的”子域”。 “业务能力”，是一个专用名词，指的是一个连续的业务过程，其中不需要中断，也不需要别的业务过程的参与。这些业务过程自然组织起来，比如首尾相连，或者，由用户参与来自然连接。 两种不同的服务划分风格，反映了对业务本身的不同的描述与划分的风格。 比较形象地讲，按子域划分，就是把业务划成一块一块的。按业务能力划分，就是把业务划成一段一段的。一块一块的，描述业务概念和它们之间的关系。一段一段的，描述业务执行的步骤和过程。 按业务能力划分的优势主要在运行时。各个服务的运行时依赖被尽量减少。在服务性能、可用性方面不会相互牵绊，可以做到最好。 而按子域划分的优势主要在设计时和演进时。有利于应对业务的规模发展、复杂性增加和分别演进。 2.2.2 共享实体\\1. 做基础包负责实体的管理，但是没有必要，一个是不同服务可能完全是两种语言，共享实体的问题不存在，2.同样语言，不同服务的编写团队不同，风格不同，规范不同，反而会引起工程管理的复杂，所以既然是微服务就遵循它的优势，足够独立； \\2. 微服务的主要优点体现在这里：你可以按照你的情况自己决定你在多大程度上共享实体。不同的语言、不同的团队、不同的业务节奏、实体上不同的关注角度，都可以导致你对实体共享的程度不同，而这些程度都可以在微服务的架构中得到支持。而且当你的共享程度在演进中发生变化的时候，微服务架构也能支持。 \\3. 请求和响应 以DTO 的形式放到一个公共的包中 gradle编译可控制哪些类不要编译 按需编译 然后DTO 和 DO 间采用 mapstruct 转换。 \\4. 解决方法有三个：1.单独将user实体类放入common包中，如果这样，user实体类的增删改查方法再auth中，但是实体类却在common中，难免有些奇怪，后期维护的时候可能会找不到这个实体类。2.将所有的entity都放入common包中。这样算然比较统一，但是对本系统进行分割，本来就是因为系统的业务比较独立，除了某些特殊情况外，实体类应该是不会有任何的共有。3.观察了一下，hr这边虽然引用了user类，但实际上只是想获取user类中的邮箱字段，既然如此，就直接写个接口返回Map即可。最后采用的是第三种解决办法，虽然说是彻底解耦了，但是只是调用一次接口就返回一个字符串，也不知道是否是最佳方案。 \\5. 独立的服务独立的数据源 entity公用就没有分库的意义了。 2.2.3 POJO DTODTO（Data Transfer Object）数据传输对象，服务间的交互使用DTO来解耦 VO（Value Object）值对象，前端展示的数据 PO（Persistant Object）持久对象 BO（Business Object）业务对象，服务内部使用的业务对象，用来存储数据库提取的数据 系统和系统的复杂度不同，协作水平不同而定，协作时保证概念一致 DTO 和 DO 间采用dozer + lombok， mapstruct 转换 2.3 微服务项目规划2.3.1 技术选型Spring Cloud Alibaba SpringCloud GateWay 网关 Nacos：服务发现、配置管理和服务管理 Feign: 服务间调用 Redis: RocketMQ： 可选： Sentinel：流量控制、熔断降级、负载保护 Ribbon:负载均衡 Spring Cloud LoadBalancer：客户端负载均衡 Seata：分布式事务 Skywalking:链路追踪 任务调度： Grafana：大屏展示-服务监控 Prometheus：监控报警-服务监控 Zipkin：调用链跟踪-服务监控 EPK：日志中心-服务监控 Security：安全审计-服务监控 2.3.2 项目文件目录规划微服务项目名称：rdp-cloud rdp-base – 公共工具类核心包 rdp-common – 公共类包 rdp-auth – 授权服务 rdp-services – 微服务 |–service-flowable – 流程微服务 |–service-user – 用户微服务 |–service-generator – 代码生成微服务 |–service-system –系统功能微服务 |–service-jog –任务服务 |…… rdp-service-api – 微服务间接口定义模块 rdp-ops – 微服务基础模块 |–gateway –Spring Cloud Gateway网关 |–register –Nacos Server |–monitor –服务监控 |–sentinel-dashboard –流量高可用 \\1. 基础类包与公共类包的处理方式？随业务变化和基本不变的类处理方式？ \\2. 微服务间 DTO 类的定义及处理方式？ \\3. rdp-services 业务服务统一归此文件下。 \\4. rdp-ops 微服务架构相关的扩展统一归此文件下。 2.4 系统介绍2.4.1 密码授权1.获取验证码 GET http://localhost:8802/auth/captcha?key=6113 \\2. 密码登录获取Token Post http://localhost:8802/auth/oauth/token 返回Response: {“access_token”:”2a60eb6a-779e-4911-9ed4-902f978d8299”,”token_type”:”bearer”,”refresh_token”:”1fde4fa4-3083-4e40-a714-fd4cf492f7a0”,”expires_in”:86399,”scope”:”all”} Authorization: Basic base64encode(username+”:”+password),username:第三方应用名称，password:密码。 使用PostMan 时，可选择Basic Auth 3.通过token获取 用户信息及权限信息 Get http://localhost:8802/auth/user Authorization: bearer 2a60eb6a-779e-4911-9ed4-902f978d8299 Authorization=bearer+token 4.检查token,检查token相应的用户及权限信息 POST http://localhost:8802/auth/oauth/check_token Authorization: Basic ZmViczoxMjM0NTY= token=b2633257-3e2d-447a-aa22-5f1fb2b4cada 5.刷新token,更新token 有效期 http://localhost:8802/auth/oauth/token 3 授权、认证服务3.1 spring-cloud-starter-securityspring-cloud-starter-security主要用来认证和授权, 怎么授权呢? spring-cloud-starter-security提供许多拦截器, 当你在登录的时候, 他就把你拦下来检查,看有没有登录信息, 如果没有就不给过, 在requestMapping上, 由于加了需要某某权限才能访问此方法, 于是又被拦下检查, 这次检查有没有需要的权限。 3.2 spring-cloud-starter-oauth2spring-cloud-starter-oauth2主要用来认证, 它只负责发放令牌, 你只要带着它要求的参数, 通过它给的路径去访问它, 他就给你一个令牌, 别的事他不管。 OAuth 2 有四种授权模式，分别是授权码模式（authorization code）、简化模式（implicit）、密码模式（resource owner password credentials）、客户端模式（client credentials）。 公司内部有很多个服务，可以专门提取出一个认证中心，这个认证中心就充当上面所说的权威认证平台的角色，所有的服务都要到这个认证中心做认证。 对于多服务的平台，可以使用 OAuth2 实现服务的单点登录，只做一次登录，就可以在多个服务中自由穿行，当然仅限于授权范围内的服务和接口。 配置最多的就是认证服务端，验证账号、密码，存储 token，检查 token ,刷新 token 等都是认证服务端的工作。 spring-cloud-starter-oauth2包含了 spring-cloud-starter-security，所以不用再单独引入了。 参考资料： code 参数换取 Token，access_token ，使用它，就可以去获取用户的资源了 https://www.cnblogs.com/xiaofengwang/p/11376881.html https://www.jianshu.com/p/a711ea5ad965 https://blog.csdn.net/j754379117/article/details/70175198 https://www.cnblogs.com/fengzheng/p/11724625.html https://www.cnblogs.com/fengzheng/p/11810340.html 流程图中，包含四个角色。 ResourceOwner为资源所有者，即为用户 User-Agent为浏览器 AuthorizationServer为认证服务器，可以理解为用户资源托管方，比如企业微信服务端 Client为第三方服务 调用流程为： A) 用户访问第三方服务，第三方服务通过构造OAuth2链接（参数包括当前第三方服务的身份ID，以及重定向URI），将用户引导到认证服务器的授权页 B) 用户选择是否同意授权 C) 若用户同意授权，则认证服务器将用户重定向到第一步指定的重定向URI，同时附上一个授权码。 D) 第三方服务收到授权码，带上授权码来源的重定向URI，向认证服务器申请凭证。 E) 认证服务器检查授权码和重定向URI的有效性，通过后颁发AccessToken（调用凭证） D)**与E)**的调用为后台调用，不通过浏览器进行 3.2.1 oauth中的角色client：调用资源服务器API的应用 Oauth 2.0 Provider：包括Authorization Server和Resource Server （1）Authorization Server：认证服务器，进行认证和授权 （2）Resource Server：资源服务器，保护受保护的资源 user：资源的拥有者 Oauth 2.0 Provider**介绍** Authorization Server: （1）AuthorizationEndpoint:进行授权的服务，Default URL: /oauth/authorize （2）TokenEndpoint：获取token的服务，Default URL: /oauth/token Resource Server: OAuth2AuthenticationProcessingFilter：给带有访问令牌的请求加载认证 3.2.2 Authorization Server1、 创建两个配置类，一个继承AuthorizationServerConfigurerAdapter，一个继承WebSecurityConfigurerAdapter。 2、 主要的两种注解： @EnableAuthorizationServer：声明一个认证服务器，当用此注解后，应用启动后将自动生成几个Endpoint： /oauth/authorize：验证 /oauth/token：获取token /oauth/confirm_access：用户授权 /oauth/error：认证失败 /oauth/check_token：资源服务器用来校验token /oauth/token_key：如果jwt模式则可以用此来从认证服务器获取公钥 以上这些endpoint都在源码里的endpoint包里面。 @Beans：需要实现AuthorizationServerConfigurer AuthorizationServerConfigurer**包含三种配置：** ClientDetailsServiceConfigurer：client客户端的信息配置 AuthorizationServerSecurityConfigurer：声明安全约束，哪些允许访问，哪些不允许访问 AuthorizationServerEndpointsConfigurer：声明授权和token的端点以及token的服务的一些配置信息，比如采用什么存储方式、token的有效期等 3.2.3 授权码授权过程 1.授权登录：用户打开第三方应用页面自动跳转到平台授权页面或者点击打开跳转到授权页面；不同平台有不同的授权页面地址。 2.授权平台：跳转页面的传参appid、redirect_uri等参数进行验证，通过则返回授权提示页面。 3.返回授权提示页面，提示用户授权的范围及应用，询问是否允许授权。 4.用户点击允许授权第三方应用，申请分配code。 5.向授权平台申请生成code，平台验证参数生成code。 6.返回code并重定向到第三方应用链接（不同平台返回链接不一样）。 7.返回第三方应用前端，第三方应用以Code向第三方服务端申请登录（带上授权平台属性）。 8.第三方服务端以code向相应授权平台申请token。 9.授权平台验证参数，返回token及时效信息。 10.第三方服务端以token到相应平台取资源信息（用户信息）。 11.返回资源信息，第三方服务端保存平台token及用户信息。 12.第三方服务端进行登录操作并返回登录信息。 注： 1、 第2**、3、4、5**步可能存在合并的情况。 2、 第11**步用户信息，需要区分租户，保存用户信息及平台ID，用户在平台上的ID。** 3、 第12**步在第三方登录授权** 与 平台授权区分，以及有效时间区分。 4、 第6**步重定向到第三方前端地址方便控制，也可重定到第三方服务端。** 4 Java基础知识4.1 EnableAutoConfiguration在一些扩展项目上，我们无法直接操作 spring 容器，可以通过 在任意src目录下添加 文件写入我们的 配置类，/META-INF/spring.factories 键值为： org.springframework.boot.autoconfigure.EnableAutoConfiguration 4.2 Filter Servlet过滤器Fileter是一个小型的web组件，它们通过拦截请求和响应，以便查看、提取或以某种方式操作客户端和服务器之间交换的数据，实现“过滤”的功能。Filter通常封装了一些功能的web组件，过滤器提供了一种面向对象的模块化机制，将任务封装到一个可插入的组件中， Filter组件通过配置文件来声明，并动态的代理。 4.3 Spring控制反转IOC、依赖注入、容器管理对象的生命周期、反射机制。 面向切面编程（AOP）框架、AspectJ、代理模式。 Spring 中使用的对象都由 IoC 容器管理，不需要我们手动使用 new 运算符创建对象。由 IoC 容器管理的对象称为 Spring Bean，Spring Bean 就是 Java 对象，和使用 new 运算符创建的对象没有区别。 Spring 通过读取 XML 或 Java 注解中的信息来获取哪些对象需要实例化。 http://c.biancheng.net/spring_boot/ 4.3.1 IOC在传统的Java编程中，当需要用到某个对象的时候，我们都是主动显式创建一个对象实例（new）。使用Spring后就不需要这样做了，因为Spring会帮我们在需要用到某些对象的地方自动注入该对象，而无须我们自己去创建。这种模式俗称控制反转，即IOC（Inversion of Control）。 @ComponentScan注解来扫描组件并注册，路径下所有被@Controller、@Service、@Repository和@Component注解标注的类都会被纳入IOC容器中。 4.3.2 注解@SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用，@SpringBootApplication是一个复合注解，包括@ComponentScan，@SpringBootConfiguration，@EnableAutoConfiguration。 @RestController的意思就是controller里面的方法都以json格式输出。 @Component将类添加进容器，@ConfigurationProperties配置文件中的数据注入到类中。 @SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到srping容器中，并且实例名就是方法名。 @EnableAutoConfiguration的作用启动自动的配置。 @EnableAutoConfiguration注解的意思就是Springboot根据你添加的jar包来配置你项目的默认配置，比如根据spring-boot-starter-web，来判断你的项目是否需要添加了webmvc和tomcat，就会自动的帮你配置web项目中所需要的默认配置。 @ComponentScan，扫描当前包及其子包下被@Component，@Controller，@Service，@Repository注解标记的类并纳入到spring容器中进行管理。 @ResponseBody 表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@esponsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@Responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。 @Controller 用于定义控制器类，在spring项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。 @RestController用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。 @Service一般用于修饰service层的组件。 @Repository 使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。 @Bean用@Bean标注方法等价于XML中配置的bean。 @Value注入Spring boot application.properties配置的属性的值。 @PropertySource 如果将所有的配置都集中到 application.properties 或 application.yml 中，那么这个配置文件会十分的臃肿且难以维护，因此我们通常会将与 Spring Boot 无关的配置（例如自定义配置）提取出来，写在一个单独的配置文件中，并在对应的 JavaBean 上使用 @PropertySource 注解指向该配置文件。 @ImportResource Spring Boot 中是不包含任何的 Spring 配置文件的，即使我们手动添加 Spring 配置文件到项目中，也不会被识别。那么 Spring Boot 项目中真的就无法导入 Spring 配置吗？答案是否定的。 Spring Boot 为了我们提供了以下 2 种方式来导入 Spring 配置： 使用 @ImportResource 注解加载 Spring 配置文件 使用全注解方式加载 Spring 配置 https://www.cnblogs.com/aademeng/articles/11218079.html 4.3.3 配置绑定SpringBoot 提供了以下 2 种方式进行配置绑定： 使用 @ConfigurationProperties 注解 使用 @Value 注解 只有在容器中的组件，才会拥有 SpringBoot 提供的强大功能。如果我们想要使用 @ConfigurationProperties 注解进行配置绑定，那么首先就要保证该对 JavaBean 对象在 IoC 容器中，所以需要用到 @Component 注解来添加组件到容器中。 @PropertySource(value = “classpath:person.properties”)//指向对应的配置文件 @Component @ConfigurationProperties(prefix = “person”) public class Person { @Value(“${person.lastName}”) private String lastName; yml 配置 与 properties 文件类似，我们也可以添加 4 个配置文件： applcation.yml：默认配置 application-dev.yml：开发环境配置 application-test.yml：测试环境配置 application-prod.yml：生产环境配置 4.3.4 Spring Boot统一日志框架SpringBoot 底层使用 slf4j+logback 的方式记录日志，当我们引入了依赖了其他日志框架的第三方框架（例如 Hibernate）时，只需要把这个框架所依赖的日志框架排除，即可实现日志框架的统一，示例代码如下。 org.apache.activemq activemq-console ${activemq.version} ​ **** ​ commons-logging ​ commons-logging ​ **** 4.3.5 Spring Boot拦截器定义拦截器 在 Spring Boot 中定义拦截器十分的简单，只需要创建一个拦截器类，并实现 HandlerInterceptor 接口即可。 注册拦截器 创建一个实现了 WebMvcConfigurer 接口的配置类（使用了 @Configuration 注解的类），重写 addInterceptors() 方法，并在该方法中调用 registry.addInterceptor() 方法将自定义的拦截器注册到容器中。 指定拦截规则 在使用 registry.addInterceptor() 方法将拦截器注册到容器中后，我们便可以继续指定拦截器的拦截规则了。 4.3.6 数据源DruidDruid 是阿里巴巴推出的一款开源的高性能数据源产品，Druid 支持所有 JDBC 兼容的数据库，包括 Oracle、MySQL、SQL Server 和 H2 等等。Druid 不仅结合了 C3P0、DBCP 和 PROXOOL 等数据源产品的优点，同时还加入了强大的监控功能。通过 Druid 的监控功能，可以实时观察数据库连接池和 SQL 的运行情况，帮助用户及时排查出系统中存在的问题。 4.3.7 Spring AOP：基于AspectJ注解开发AOP底层为动态代理，AOP指的是：在程序运行期间动态地将某段代码切入到指定方法指定位置进行运行的编程方式，相关设计模式为代理模式。面向切面编程（AOP）框架、AspectJ、代理模式。 定义切面@Aspect @Aspect public class AspectModule { 定义切入点@Pointcut // 要求：方法必须是private，返回值类型为void，名称自定义，没有参数 @Pointcut(“execution(net.biancheng...*(..))”) private void myPointCut() { } 定义通知advice @AspectJ 支持 5 种类型的 advice，以下为使用 @Before 的示例。 @Before(“myPointCut()”) public void beforeAdvice(){ 4.3.8 事务事务具有以下 4 个特性，即原子性、一致性、隔离性和持久性，这 4 个属性称为 ACID 特性。 原子性（Atomicity）：一个事务是一个不可分割的工作单位，事务中包括的动作要么都做要么都不做。 一致性（Consistency）：事务必须保证数据库从一个一致性状态变到另一个一致性状态，一致性和原子性是密切相关的。 隔离性（Isolation）：一个事务的执行不能被其它事务干扰，即一个事务内部的操作及使用的数据对并发的其它事务是隔离的，并发执行的各个事务之间不能互相打扰。 持久性（Durability）：持久性也称为永久性，指一个事务一旦提交，它对数据库中数据的改变就是永久性的，后面的其它操作和故障都不应该对其有任何影响。 4.3.9 java的反射机制Java语言允许通过程序化的方式间接对Class的对象实例操作，Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：构造函数、属性和方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能.","link":"/2021/09/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"},{"title":"舒适终端","text":"iTerm2 + Oh My Zsh自定义终端（Mac） homebrew、Xcode、git、iterm2、zsh Step1 下载iTerm2下载地址：https://www.iterm2.com/ 老版本MacOS需手动切换zsh，执行以下命令 1chsh -s /bin/zsh 如果想切回bash，执行以下命令 1chsh -s /bin/bash Step2 安装Oh My Zshcurl安装 1# curl 安装方式2sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" wget安装 1# wget 安装方式2sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 地址：https://github.com/robbyrussell/oh-my-zsh Step3 安装PowerLine首先安装pip，已经安装的跳过 1sudo easy_install pip 安装powerline 1pip install powerline-status --user Step3 选择字体和配色iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text自行选择 Step4 选择主题下载agnoster主题 1cd ~/Desktop/OpenSource2git clone https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor.git3cd oh-my-zsh-agnoster-fcamblor/4./install 打开zshrc配置文件，将ZSH_THEME后面的字段改为”agnoster” 1oepn ~/.zshrc 修改完成后，执行配置 1source ~/.zshrc Step5 安装高亮插件1cd ~/.oh-my-zsh/custom/plugins/2git clone https://github.com/zsh-users/zsh-syntax-highlighting.git3open ~/.zshrc 这时我们再次打开zshrc文件进行编辑。找到plugins，此时plugins中应该已经有了git，我们需要把高亮插件也加上： 请务必保证插件顺序，zsh-syntax-highlighting必须在最后一个。 然后在文件的最后一行添加：source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 执行命令使刚才的修改生效： 1source ~/.zshrc 最后愉快的去使用吧！","link":"/2019/12/24/%E8%88%92%E9%80%82%E7%BB%88%E7%AB%AF/"},{"title":"正则表达式全集","text":"字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo能匹配“z”以及“zoo”。等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（,+,?，{*n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“`(. (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\\(”或“\\)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`( (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows`”。 x|y 匹配x或y。例如，“`z [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \\d 匹配一个数字字符。等价于[0-9]。 \\D 匹配一个非数字字符。等价于[^0-9]。 \\f 匹配一个换页符。等价于\\x0c和\\cL。 \\n 匹配一个换行符。等价于\\x0a和\\cJ。 \\r 匹配一个回车符。等价于\\x0d和\\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于\\x09和\\cI。 \\v 匹配一个垂直制表符。等价于\\x0b和\\cK。 \\w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04&amp;1”。正则表达式中可以使用ASCII编码。. *num* 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。 *n* 标识一个八进制转义值或一个向后引用。如果*n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n*为一个八进制转义值。 *nm* 标识一个八进制转义值或一个向后引用。如果*nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm*。 *nml* 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 常用正则表达式 用户名 /^[a-z0-9_-]{3,16}$/ 密码 /^[a-z0-9_-]{6,18}$/ 十六进制值 /^#?([a-f0-9]{6}|[a-f0-9]{3})$/ 电子邮箱 /^([a-z0-9_.-]+)@([\\da-z.-]+).([a-z.]{2,6})$/ /^[a-z\\d]+(.[a-z\\d]+)*@(\\da-z?)+(.{1,2}[a-z]+)+$/ URL /^(https?://)?([\\da-z.-]+).([a-z.]{2,6})([/\\w .-])/?$/ IP 地址 /((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)/ /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/ HTML 标签 /^&lt;([a-z]+)([^&lt;]+)(?:&gt;(.)&lt;/\\1&gt;|\\s+/&gt;)$/ 删除代码\\注释 (?&lt;!http:|\\S)//.*$ Unicode编码中的汉字范围 /^[\\u2E80-\\u9FFF]+$/","link":"/2020/04/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A8%E9%9B%86/"},{"title":"面向对象的一些事","text":"由来 很久以前，软件开发的世界还是一片浑浑噩噩，不管开发什么软件都面临着复杂性这个问题，代码里面到处是goto语句，程序的流程随意跳转。众生写代码时，越写到后面越不知道自己写的是什么。这时候出现一位巨人，他就是结构化编程。 结构化编程的基本思想是：有序地控制流程，即把程序的执行顺序限制为顺序、分支和循环这三种；把共通的处理归结为例程（函数）。 虽然结构化解决了程序控制流的复杂问题，但程序里面不仅包括控制结构，还包括要处理的数据。随着处理数据的增加，程序的复杂性也会上升。这时候，面向对象编程来了！ Simula 面向对象技术最早是在编程语言Simula中提出的。1967年5月20日，在挪威奥斯陆郊外的小镇莉沙布举行的IFIP TC-2 工作会议上，挪威科学家Ole-Johan Dahl和Kristen Nygaard正式发布了Simula 67语言。Simula 67被认为是最早的面向对象程序设计语言，是面向对象的开山祖师，它引入了所有后来面向对象程序设计语言所遵循的基础概念：对象、类、继承，但它的实现并不是很完整。 Simula虽然最早提出面向对象的概念，但因为其本身复杂，比较难学，而并没有大规模流行。但Simula提出的面向对象的概念对程序语言后继的发展产生了巨大和深远的影响。 Smalltalk Smalltalk是公认为历史上第二个面向对象的程序语言，而且是第一个完整实现了面向对象技术的语言。 最早的Smalltalk原型由艾伦·凯于70年代初提出。类（来自Simula-67）、海龟绘图（来自MIT的LOGO）以及图形界面等概念的有机组合，构成了Smalltalk的最初的蓝图。在1971年到1975年之间，艾伦·凯在Xerox PARC的小组设计并实现了第一个真正的Smalltalk语言系统。 Smalltalk引领了面向对象的设计思想的思潮，对其它众多的程序设计语言的产生起到了极大的推动作用。C++，C#，Objective-C，Actor，Java和Ruby等，无一不受到Smalltalk的影响，这些程序语言中也随处可见Smalltalk的影子。 除了编程语言受到Smalltalk的影响外，90年代的许多软件开发思想得利于Smalltalk，例如设计模式、敏捷编程和代码重构等。 面向对象与基于对象的区别 “面向对象”和“基于对象”两个不同的概念。面向对象的三大特点（封装，继承，多态）缺一不可，通常“基于对象”使用对象，但是无法利用现有的对象模板产生新的对象类型，继而产生新的对象，也就是说“基于对象”没有继承的特点，而“多态”是表示为父类类型的子类对象实例，没有了继承的概念也就无从谈论“多态”。现在的很多流行技术都是基于对象的，它们使用一些封装好的对象，调用对象的方法，设置对象的属性。但是它们无法让程序员派生新对象类型。他们只能使用现有对象的方法和属性。所以当你判断一个新的技术是否是面向对象的时候，通常可以使用后两个特性来加以判断。 面向对象的三个基本特征继承 继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。 实现继承是指直接使用基类的属性和方法而无需额外编码的能力； 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。 多态 多态即一个名字有多种语义，一个词法元素可以作多种解释。面向对象系统，对象封装了操作，利用重名的操作，让各对象自己去释意执行，这种多义性不会带来混淆，方便与高层设计。虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。 封装 面向对象的诸多优点是靠封装手段得到“对象”而获得的。封装的目的在于将对象用户和对象的实现者分开，用户不必知道对象行为实现的细节，只要以实现者提供的消息来访问该对象。封装是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。 最后1、抽象会使复杂的问题更加简单化。2、从以前面向过程的执行者，变成了张张嘴的指挥者。3、面向对象更符合人类的思维，面向过程则是机器的思想","link":"/2020/04/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"}],"tags":[],"categories":[]}